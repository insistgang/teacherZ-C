# 第二课：ROF模型的完整数学推导

> **深度解析**: 从能量泛函到数值算法的每一步
> **数学水平**: 需要多元微积分和基础PDE知识
> **学习目标**: 能够独立推导并实现ROF算法

---

## Part 1: ROF问题的数学表述

### 1.1 函数空间的严格定义

**为什么要定义函数空间？**
- ROF问题的解u可能有不连续（边缘）
- 传统L²空间不够用
- 需要**有界变分函数空间 (BV)**

**定义：BV空间**
```
BV(Ω) = {u: Ω → ℝ | TV(u) < ∞}

其中 TV(u) = sup{∫u·div(φ)dx : φ ∈ C_c¹(Ω, ℝ²), |φ| ≤ 1}
```

**直观理解**：
- BV函数可以有跳跃不连续
- BV函数的广义导度是**测度**（可能包含Dirac测度）
- BV ⊂ L¹（BV函数都是可积的）

**性质**：
1. **下紧性**: 如果 {u_n} 是BV中有界序列，则存在子列收敛
2. **下半连续性**: TV泛函是下半连续的
3. **存在性**: BV中闭凸集是弱紧的

---

### 1.2 ROF问题的严格表述

**原问题（原始形式）**：
```
min_u E(u) = ∫_Ω |∇u| dx + (λ/2) ∫_Ω (u-f)² dx
s.t.     u ∈ BV(Ω)
```

**符号说明**：
- Ω ⊂ ℝ²：图像域（通常是矩形）
- u：待求的去噪图像
- f：观察到的含噪图像
- λ > 0：正则化参数
- |∇u|：TV半范数（对于广义导度）

---

## Part 2: 欧拉-拉格朗日方程推导

### 2.1 变分法基本定理

**定理（变分法基本引理）**：

如果对所有 φ ∈ C_c∞(Ω)（光滑紧支测试函数）都有
```
∫_Ω v(x)φ(x) dx = 0
```
则 v(x) = 0 几乎处处。

**意义**：这让我们从积分形式推导到点wise的微分方程。

---

### 2.2 计算第一变分

**步骤1：考虑扰动**
```
u_ε = u + εφ
```
其中 φ 是任意测试函数，ε 是小参数。

**步骤2：将 u_ε 代入能量泛函**
```
E(u_ε) = ∫ |∇(u+εφ)| + (λ/2)(u+εf-f)² dx
```

**步骤3：在 ε = 0 处求导**
```
δE = d/dε E(u+εφ)|ε=0
```

---

### 2.3 处理TV项的困难

**问题**：|∇u| 在 ∇u = 0 处不可微！

**解决方案1：正则化方法**

用光滑近似：
```
|∇u| ≈ √(|∇u|² + β²)
```
其中 β > 0 是小参数。

**计算**：
```
设 F(∇u) = √(|∇u|² + β²) = √(u_x² + u_y² + β²)

∂F/∂u_x = u_x / √(u_x² + u_y² + β²)
∂F/∂u_y = u_y / √(u_x² + u_y² + β²)
```

**第一变分**：
```
d/dε ∫ √(|∇(u+εφ)|² + β²) dx |ε=0

= ∫ [∂F/∂u_x · φ_x + ∂F/∂u_y · φ_y] dx

= ∫ [u_x/√(...) · φ_x + u_y/√(...) · φ_y] dx
```

---

### 2.4 分部积分（格林公式）

**目标**：将 φ_x, φ_y 转移到 φ

**格林公式（分部积分）**：
```
∫_Ω a·∇φ dx = -∫_Ω φ·div(a) dx + ∫_∂Ω φ·a·n ds
```

**应用到我们的问题**：
```
设 a = (u_x, u_y) / √(u_x² + u_y² + β²)

则：
∫ [a₁φ_x + a₂φ_y] dx
= -∫ φ(a₁_x + a₂_y) dx + ∮_∂Ω φ(a₁n₁ + a₂n₂) ds
```

**Neumann边界条件**：
```
在 ∂Ω 上：∂u/∂n = 0
这消除了边界项。
```

**因此**：
```
∫ [a₁φ_x + a₂φ_y] dx = -∫ φ·div(a) dx
```

---

### 2.5 保真项的变分

**计算**：
```
d/dε (λ/2) ∫ (u+εf-f)² dx |ε=0

= λ ∫ (u-f)φ dx
```

---

### 2.6 合并并令第一变分为零

**总的第一变分**：
```
δE = ∫ [-div(∇u/√(|∇u|²+β²)) + λ(u-f)] φ dx = 0
```

**由于 φ 是任意的**，根据变分法基本引理：
```
-div(∇u/√(|∇u|²+β²)) + λ(u-f) = 0
```

---

### 2.7 令 β → 0 取极限

**我们得到欧拉-拉格朗日方程**：
```
-div(∇u/|∇u|) + λ(u-f) = 0
```

**这就是ROF模型的E-L方程！**

---

### 2.8 E-L方程的物理解释

**展开散度项**：
```
div(∇u/|∇u|) = ∂/∂x(u_x/|∇u|) + ∂/∂y(u_y/|∇u|)
```

**曲率项的几何意义**：

在等照度线 {x : u(x) = c} 上：
```
κ = div(∇u/|∇u|)
```
这就是**平均曲率**！

**E-L方程重写**：
```
-κ + λ(u-f) = 0

即：曲率 = 数据拉力
```

**物理平衡**：
- 曲率项 κ：使曲线变直（平滑）
- 数据项 λ(u-f)：拉向观察数据
- 最优解是两者的平衡

---

## Part 3: 数值求解方法

### 3.1 方法1：梯度下降法（最直观）

**思想**：沿着能量下降的方向迭代

**梯度下降流**：
```
∂u/∂t = div(∇u/|∇u|) - λ(u-f)
```

**离散化（前向欧拉）**：
```
u^{k+1}_{i,j} = u^k_{i,j} + Δt [div^k_{i,j} - λ(u^k_{i,j} - f_{i,j})]
```

**散度的离散化**：
```
div(∇u/|∇u|)_{i,j}
= D_x[u_x/|∇u|]_{i,j} + D_y[u_y/|∇u|]_{i,j}

其中：
D_x[v]_{i,j} = (v_{i,j} - v_{i-1,j})/h
D_y[v]_{i,j} = (v_{i,j} - v_{i,j-1})/h
```

**梯度的离散化**：
```
u_x|_{i,j} ≈ (u_{i+1,j} - u_{i,j})/h
u_y|_{i,j} ≈ (u_{i,j+1} - u_{i,j})/h
```

**正则化（避免除零）**：
```
|∇u| ≈ √(u_x² + u_y² + ε²)
```

**CFL条件**（保证稳定性）：
```
Δt ≤ h²/4
```

对于 h = 1（像素间距），Δt ≤ 0.25

---

### 3.2 方法2：不动点迭代

**从E-L方程重新排列**：
```
-div(∇u/|∇u|) + λ(u-f) = 0

λu = λf + div(∇u/|∇u|)

u = f + (1/λ) div(∇u/|∇u|)
```

**迭代格式**：
```
u^{k+1} = f + (1/λ) div(∇u^k/|∇u^k|)
```

**优点**：比梯度下降快
**缺点**：可能不稳定

---

### 3.3 方法3：Chambolle投影算法（现代方法）

**思想**：引入对偶变量，将问题转化为投影

**对偶问题推导**：

**原始问题**：
```
min_u ∫|∇u| + (λ/2)(u-f)²
```

**辅助变量**：设 p = ∇u，约束 |p| ≤ 1

**拉格朗日形式**：
```
L(u,p) = ∫|p| + (λ/2)(u-f)² + (μ/2)|p-∇u|²
```

**对偶问题**（经过推导）：
```
min_p ∫|p|² - λf·div(p)
s.t.  |p| ≤ 1
```

**Chambolle迭代**：
```
p^{k+1} = (p^k + τ∇(div(p^k) - λf)) / (1 + τ|∇(div(p^k) - λf)|)
```

**恢复u**：
```
u = f - (1/λ)div(p)
```

**参数**：τ ≤ 1/4 保证收敛

---

### 3.4 方法4：Split Bregman（最快）

**Bregman距离**：
```
D^J_J(u,v) = J(u) - J(v) - <p, u-v>
```
其中 p ∈ ∂J(v) 是次梯度

**应用到TV问题**：

**辅助变量**：v = ∇u

**增广拉格朗日**：
```
L(u,v,b) = ∫|v| + (λ/2)(u-f)² + (μ/2)|v-∇u-b|²
```

**交替优化**：

**u-子问题**（线性Poisson方程）：
```
(λI - μΔ)u = λf + μ·div(v-b)
```

**v-子问题**（收缩）：
```
v = shrink(∇u + b, 1/μ)

shrink(x, κ) = x/|x| · max(|x|-κ, 0)
```

**b-更新**（Bregman迭代）：
```
b = b + ∇u - v
```

---

## Part 4: 完整推导示例

### 4.1 一维ROF的解析解

**问题**：
```
min_u ∫|u'| + (λ/2)(u-f)² dx
```

**E-L方程**：
```
-d/dx(u'/|u'|) + λ(u-f) = 0
```

**情况1：u' ≠ 0（平滑区域）**
```
u'/|u'| = sign(u') = ±1（常数）

d/dx(sign(u')) = 0

因此：λ(u-f) = 0 → u = f
```

**情况2：u' = 0（常数区域）**
```
λ(u-f) = 0 → u = f
```

**特殊情况：阶梯函数**

设：
```
u(x) = {c₁, x < x₀
        {c₂, x ≥ x₀
```

在 x₀ 处有跳跃，u' 包含Dirac测度 δ(x-x₀)

**能量**：
```
E = |c₂-c₁| + (λ/2)[∫_{-∞}^{x₀}(c₁-f)² + ∫_{x₀}^{∞}(c₂-f)²]
```

对 c₁, c₂ 求极值：
```
∂E/∂c₁ = -sign(c₂-c₁) + λ∫_{-∞}^{x₀}(c₁-f) = 0
∂E/∂c₂ = sign(c₂-c₁) + λ∫_{x₀}^{∞}(c₂-f) = 0
```

这给出了c₁, c₂的隐式方程。

---

### 4.2 二维阶梯函数的解

**假设**：图像是分段常数
```
u(x) = {c₁, x ∈ Ω₁
        {c₂, x ∈ Ω₂
```

其中 Ω = Ω₁ ∪ Ω₂，Γ = ∂Ω₁ ∩ ∂Ω₂ 是边界

**能量**：
```
E = |Γ| + (λ/2)[∫_Ω₁(c₁-f)² + ∫_Ω₂(c₂-f)²]
```

对 c₁ 求导：
```
∂E/∂c₁ = λ∫_Ω₁(c₁-f) = 0

c₁ = (1/|Ω₁|)∫_Ω₁ f
```

**这就是Chan-Vese模型的特殊形式！**

---

## Part 5: 收敛性分析

### 5.1 存在性定理

**定理**：给定 f ∈ L²(Ω)，ROF问题在BV(Ω)中存在唯一解。

**证明大纲**：

1. **下半连续性**
   - TV泛函是下半连续的
   - L²范数是下半连续的
   - 因此E(u)下半连续

2. **紧性**
   - BV空间弱紧嵌入L²
   - 最小化序列有收敛子列

3. **唯一性**
   - 能量泛函是严格凸的
   - 因此解唯一

---

### 5.2 梯度下降法的收敛性

**定理**：设u^k由梯度下降产生，则：
1. E(u^k)单调递减
2. u^k收敛到E的极小值

**证明**：
```
E(u^{k+1}) = E(u^k + Δt·g^k)
          = E(u^k) + Δt<∇E(u^k), g^k> + O(Δt²)

由于 g^k = -∇E(u^k)，有：
E(u^{k+1}) = E(u^k) - Δt|∇E(u^k)|² + O(Δt²)
          ≤ E(u^k) （当Δt充分小）
```

---

### 5.3 Chambolle算法的收敛性

**定理**：Chambolle迭代产生的序列p^k收敛到对偶问题的解。

**关键**：算法是对偶问题的不动点迭代
```
p* = (p* + τ∇(div(p*) - λf)) / (1 + τ|∇(div(p*) - λf)|)
```

---

## Part 6: 实现细节

### 6.1 边界条件的处理

**Neumann边界条件**：
```
∂u/∂n = 0 在 ∂Ω 上
```

**离散实现**：
```python
# 在边界处，使用镜像延拓
u[-1, :] = u[0, :]      # 左边界
u[-1, :] = u[-2, :]     # 右边界
u[:, -1] = u[:, 0]      # 上边界
u[:, -1] = u[:, -2]     # 下边界
```

### 6.2 正则化参数的选择

**ε 的选择**：
```
ε = 10^{-6} 到 10^{-4}
```
- 太大：过度光滑
- 太小：数值不稳定

**λ 的选择**：
```
λ ∝ σ²/σ₀²
```
其中σ是噪声标准差，σ₀是图像标准差的估计。

**经验值**：
```
λ = 0.01 - 0.3（对于归一化到[0,1]的图像）
```

---

## Part 7: 代码实现

### 7.1 从零实现梯度下降法

```python
import numpy as np

def rof_gradient_descent(f, lambda_=0.1, max_iter=1000, dt=0.1, eps=1e-6):
    """
    从零实现ROF的梯度下降法

    Parameters:
    -----------
    f : ndarray
        含噪图像
    lambda_ : float
        正则化参数
    max_iter : int
        最大迭代次数
    dt : float
        时间步长（满足CFL条件：dt <= 0.25）
    eps : float
        正则化参数
    """
    u = f.copy()
    n_rows, n_cols = f.shape

    for k in range(max_iter):
        # 计算梯度
        grad_x = np.zeros_like(u)
        grad_y = np.zeros_like(u)

        grad_x[:, :-1] = u[:, 1:] - u[:, :-1]
        grad_y[:-1, :] = u[1:, :] - u[:-1, :]

        # TV梯度的大小
        grad_norm = np.sqrt(grad_x**2 + grad_y**2 + eps**2)

        # 计算散度
        div_term = np.zeros_like(u)

        # div(∇u/|∇u|)
        term_x = grad_x / grad_norm
        term_y = grad_y / grad_norm

        div_term[:, :-1] += term_x[:, :-1]
        div_term[:, 1:]  -= term_x[:, :-1]
        div_term[:-1, :] += term_y[:-1, :]
        div_term[1:, :]  -= term_y[:-1, :]

        # 数据项
        data_term = lambda_ * (u - f)

        # 梯度下降更新
        u_new = u + dt * (div_term - data_term)

        # 检查收敛
        if np.linalg.norm(u_new - u) / np.linalg.norm(u) < 1e-4:
            print(f"收敛于迭代 {k}")
            break

        u = u_new

    return u
```

### 7.2 验证实现

```python
from skimage.restoration import denoise_tv_chambolle
from skimage import data, img_as_float
import matplotlib.pyplot as plt

# 测试图像
f = img_as_float(data.camera())
f_noisy = f + 0.1 * np.random.randn(*f.shape)

# 自己的实现
u_my = rof_gradient_descent(f_noisy, lambda_=0.15, max_iter=500)

# scikit-image的实现
u_skimage = denoise_tv_chambolle(f_noisy, weight=0.15)

# 对比
fig, axes = plt.subplots(1, 4, figsize=(16, 4))

axes[0].imshow(f, cmap='gray')
axes[0].set_title('Original')

axes[1].imshow(f_noisy, cmap='gray')
axes[1].set_title('Noisy')

axes[2].imshow(u_my, cmap='gray')
axes[2].set_title('My Implementation')

axes[3].imshow(u_skimage, cmap='gray')
axes[3].set_title('scikit-image')

plt.show()
```

---

## Part 8: 高级主题

### 8.1 非局部TV

**动机**：TV只利用局部梯度，容易产生阶梯效应

**定义**：
```
NLTV(u) = ∫∫√(|u(x)-u(y)|²) w(x,y) dx dy
```

其中 w(x,y) 是基于patch相似性的权重。

### 8.2 高阶TV

**动机**：减少阶梯效应

**定义**：
```
TGV²(u) = min_w α₁∫|∇u - w| + α₂∫|ε(w)|
```

其中 ε(w) 是对称梯度。

### 8.3 彩色图像的TV

**向量TV**：
```
TV(u) = ∫√(Σᵢ|∇uᵢ|²) dx
```

**或通道独立**：
```
TV(u) = Σᵢ∫|∇uᵢ| dx
```

---

## 课后练习

### 练习1：手写推导

用纸笔推导：
1. E-L方程的完整推导
2. Chambolle算法的迭代公式
3. Split Bregman的三个子问题

### 练习2：代码实现

实现并对比三种方法：
1. 梯度下降法
2. Chambolle投影算法
3. Split Bregman方法

对比：
- 收敛速度（迭代次数 vs 时间）
- 数值稳定性
- 参数敏感性

### 练习3：理论分析

证明：
1. TV是凸泛函
2. ROF能量泛函是严格凸的
3. 解的唯一性

---

## 参考文献深入阅读

1. **Rudin-Osher-Fatemi (1992)**: 原始论文，必读
2. **Chambolle (2004)**: 投影算法的原始论文
3. **Goldstein-Osher (2009)**: Split Bregman方法
4. **Strong-Chan (2003)**: 边界条件分析

---

**下一课预告**：从ROF到Mumford-Shah：分割问题
