# 第四课：凸松弛与图割 - 让Mumford-Shah可求解

> **核心问题**: Mumford-Shah是NP难问题，如何求解？
> **解决方案**: 凸松弛 + 图割 = 全局最优解
> **数学难度**: ⭐⭐⭐⭐⭐ (最有挑战性)
> **实用价值**: ⭐⭐⭐⭐⭐ (工业界标准方法)

---

## Part 1: 为什么需要凸松弛？

### 1.1 Mumford-Shah的计算困难

**完整Mumford-Shah问题**：
```
min_{u,Γ} ∫_{Ω\Γ} |∇u|² + μ∫_Ω (u-f)² + ν|Γ|
```

**三大挑战**：

#### **挑战1：非凸性**
```
变量Γ是离散的（边缘存在或不存在）
→ 能量泛函非凸
→ 多个局部极小值
→ 难以找到全局最优
```

**示例**：简单的二值分割
```
每个像素：标签 0 或 1
总共有 2^(n×m) 种可能！
对于256×256图像：2^65536 ≈ 10^19713 种可能
```

#### **挑战2：自由边界**
```
Γ的位置未知
Γ的形状未知
Γ的拓扑未知
→ 这是一个自由边界问题
```

#### **挑战3：变量耦合**
```
u 和 Γ 相互依赖：
├── 给定Γ，求u容易（Poisson方程）
├── 给定u，求Γ困难（组合优化）
└── 需要交替优化，可能陷入局部极小
```

---

### 1.2 凸松弛的核心思想

**思想**：将原问题嵌入到更大的凸问题中

**步骤**：
```
1. 原问题（非凸，难）
   min E(x)  s.t.  x ∈ {0,1}^n

2. 松弛（凸，易）
   min E(x)  s.t.  x ∈ [0,1]^n

3. 求解凸问题
   x* ∈ [0,1]^n

4. 如果x* ∈ {0,1}^n → 松弛是紧的
   如果x* ∉ {0,1}^n → 需要后处理
```

**关键**：如果松弛是"紧"的（tight），则凸问题的解就是原问题的解！

---

### 1.3 两类松弛方法

#### **方法1：变量松弛（Variable Relaxation）**

**技巧**：引入辅助变量

**原问题**：
```
min_u ∫|∇u| + (λ/2)(u-f)²
```

**松弛**：引入 v = ∇u
```
min_{u,v} ∫|v| + (λ/2)(u-f)²
s.t.      v = ∇u
```

**增广拉格朗日**：
```
L(u,v) = ∫|v| + (λ/2)(u-f)² + (β/2)|v-∇u|²
```

#### **方法2：值域松弛（Range Relaxation）**

**技巧**：放松变量的取值范围

**原问题**（二值分割）：
```
u ∈ {0, 1}
```

**松弛**：
```
u ∈ [0, 1]
```

**关键问题**：什么时候松弛是紧的？

---

## Part 2: 凸优化基础

### 2.1 凸集与凸函数

**凸集**：
```
C 是凸集，如果：
∀x,y ∈ C, ∀θ ∈ [0,1]: θx + (1-θ)y ∈ C
```

**示例**：
- [0,1] 区间是凸集 ✓
- {0,1} 集合不是凸集 ✗

**凸函数**：
```
f 是凸函数，如果：
∀x,y, ∀θ ∈ [0,1]:
f(θx + (1-θ)y) ≤ θf(x) + (1-θ)f(y)
```

**关键性质**：
```
凸优化问题：
min f(x) s.t. x ∈ C

如果f是凸函数，C是凸集：
→ 局部极小值 = 全局极小值 ✓
→ 不存在多个局部极小值 ✓
→ 可以高效求解 ✓
```

---

### 2.2 电视（Total Variation）的凸性

**定义**：
```
TV(u) = ∫|∇u| dx
```

**凸性证明**：
```
设 u₁, u₂ 是两个函数，θ ∈ [0,1]

TV(θu₁ + (1-θ)u₂)
= ∫|∇(θu₁ + (1-θ)u₂)|
= ∫|θ∇u₁ + (1-θ)∇u₂|
≤ ∫(θ|∇u₁| + (1-θ)|∇u₂|)  (三角不等式)
= θ∫|∇u₁| + (1-θ)∫|∇u₂|
= θ·TV(u₁) + (1-θ)·TV(u₂)

因此：TV是凸泛函 ✓
```

**意义**：
```
ROF问题：min_u TV(u) + (λ/2)(u-f)²
       ↑ 凸      ↑ 凸
    = 凸优化问题
    = 全局唯一解
```

---

### 2.3 为什么Mumford-Shah是非凸的？

**原因**：边缘集合 Γ 的离散性

**示例**：一维情况
```
考虑函数 u(x) = {0, x < x₀
               {1, x ≥ x₀

问题：找最优的 x₀（边缘位置）

能量 E(x₀) = 1 + ∫(u-f)²
           ↑
       边缘长度（固定）

但是：x₀ 只能取有限个值（离散）
      → 不是凸优化问题
```

---

## Part 3: 图割基础

### 3.1 什么是图割？

**定义**：给定一个有向图 G = (V, E)，将顶点分为两个集合 S 和 T

**割**：
```
S ∪ T = V
S ∩ T = ∅
```

**割的容量**：
```
capacity(S,T) = Σ_{u∈S, v∈T} c(u,v)
```
其中 c(u,v) 是边(u,v)的容量

**最小割问题**：
```
min capacity(S,T)
s.t. S ∪ T = V, S ∩ T = ∅
```

---

### 3.2 最大流最小割定理

**定理**：
```
max flow = min cut
```

**意义**：
- 可以用最大流算法求最小割
- 复杂度 O(n²√m) 或 O(n³)
- 高效且全局最优

**实现**：
- Boykov-Kolmogorov算法
- Push-relabel算法
- Python库：NetworkX, PyMaxflow

---

### 3.3 将图像分割转化为图割

**关键**：构造合适的图

**构造方法**：
```
顶点：
├── 源点 s（source）
├── 汇点 t（sink）
└── 每个像素一个顶点

边：
├── s-像素边（前景概率）
├── 像素-t边（背景概率）
└── 像素-像素边（平滑项）
```

**边的容量设计**：
```
c(s, u_i) = -log P(标签=前景 | f_i)
c(u_i, t) = -log P(标签=背景 | f_i)
c(u_i, u_j) = λ · exp(-|f_i - f_j|²/σ²)
```

---

### 3.4 图割能量

**能量泛函**：
```
E(L) = Σ D_i(L_i) + Σ_{i,j} V_{i,j}(L_i, L_j)
       ↑                ↑
    数据项          平滑项
```

**与Mumford-Shah的联系**：
```
完整MS:  ∫|∇u|² + μ∫(u-f)² + ν|Γ|
图割:    Σ平滑项 + Σ数据项

简化：
→ u在区域内是常数
→ |∇u|² 变成 Potts模型
```

---

## Part 4: 二值图像分割的图割方法

### 4.1 问题建模

**二值分割**：
```
每个像素 i：标签 L_i ∈ {0, 1}

L_i = 0: 背景
L_i = 1: 前景
```

**能量**：
```
E(L) = Σ_{i} D_i(L_i) + Σ_{i,j} V_{i,j}(L_i, L_j)
```

**数据项**：
```
D_i(0) = w_i^0 = (f_i - μ₀)²  # 背景拟合度
D_i(1) = w_i^1 = (f_i - μ₁)²  # 前景拟合度
```

**平滑项（Potts模型）**：
```
V_{i,j}(L_i, L_j) = {λ,  if L_i ≠ L_j
                   {0,  if L_i = L_j
```

---

### 4.2 图构造

**顶点**：
```
V = {s, t} ∪ {像素1, 2, ..., n}
```

**边和容量**：
```
1. s-像素边（t-links）：
   c(s, i) = D_i(1)  # 像素i为前景的代价
   c(i, t) = D_i(0)  # 像素i为背景的代价

2. 像素-像素边（n-links）：
   c(i, j) = V_{i,j}(0, 1) = λ  # 邻居标签不同的代价
```

**最小割对应分割**：
```
S = {s} ∪ {标签为1的像素}
T = {t} ∪ {标签为0的像素}

最小割 = 最小能量
```

---

### 4.3 完整算法流程

```
步骤1：参数估计
├── 计算全局均值 μ₀, μ₁
└── 设置平滑参数 λ

步骤2：构造图
├── 添加顶点（源点、汇点、像素）
├── 添加t-links（数据项）
└── 添加n-links（平滑项）

步骤3：计算最小割
├── 使用max-flow算法
└── 得到S和T

步骤4：提取分割结果
└── 像素∈S → 前景，像素∈T → 背景
```

---

## Part 5: 凸松弛方法详解

### 5.1 连续松弛

**原问题**：
```
min E(L) s.t. L_i ∈ {0, 1}
```

**松弛**：
```
min E(L) s.t. L_i ∈ [0, 1]
```

**求解**：
```
这是凸优化问题！
→ 可以用梯度下降、原对偶方法等
→ 全局最优解
```

**问题**：解可能不是二值的

**解决方案**：取阈值
```
L_i* = 1 if u_i > 0.5
L_i* = 0 if u_i ≤ 0.5
```

---

### 5.2 变量分裂方法

**思想**：将耦合的变量分开

**示例**：ROF模型

**原问题**：
```
min_u ∫|∇u| + (λ/2)(u-f)²
```

**引入变量 v = ∇u**：
```
min_{u,v} ∫|v| + (λ/2)(u-f)²
s.t.      v = ∇u
```

**增广拉格朗日**：
```
L(u,v,b) = ∫|v| + (λ/2)(u-f)² + (β/2)|v-∇u-b|²
```

**交替优化**：
```
1. u子问题：线性Poisson方程
2. v子问题：收缩公式
3. b更新：Bregman迭代
```

---

### 5.3 Split Bregman算法

**完整的Split Bregman**：

```python
def split_bregman_rof(f, lambda_, mu, max_iter=100):
    """
    Split Bregman算法求解ROF

    参数:
    f: 输入图像
    lambda_: 保真参数
    mu: 增广拉格朗日参数
    """
    u = f.copy()
    dx = np.zeros_like(f)
    dy = np.zeros_like(f)
    bx = np.zeros_like(f)
    by = np.zeros_like(f)

    for k in range(max_iter):
        # u子问题：求解Poisson方程
        # (λI - μΔ)u = λf + μ·div(dx-bx, dy-by)

        # FFT求解（快速）
        # u = ifft2((λf_hat + μ·div_hat) / (λ + μ·|ξ|²))

        # v子问题：收缩
        # dx = shrink(∂u/∂x + bx, 1/μ)
        # dy = shrink(∂u/∂y + by, 1/μ)

        # b更新
        # bx = bx + (∂u/∂x - dx)
        # by = by + (∂u/∂y - dy)

    return u
```

---

## Part 6: 图割代码实现

### 6.1 使用NetworkX实现图割

```python
import networkx as nx
import numpy as np

def graph_cut_segmentation(f, lambda_=1.0):
    """
    使用图割进行二值分割

    参数:
    f: 输入灰度图像
    lambda_: 平滑参数
    """
    H, W = f.shape
    n_pixels = H * W

    # 创建有向图
    G = nx.DiGraph()

    # 添加顶点
    G.add_node('s')  # 源点
    G.add_node('t')  # 汇点
    for i in range(n_pixels):
        G.add_node(i)

    # 估计前景和背景均值
    mu_bg = np.mean(f)
    mu_fg = np.mean(f[f > mu_bg])

    # 添加边
    for i in range(H):
        for j in range(W):
            idx = i * W + j
            pixel_val = f[i, j]

            # t-links：数据项
            # 容量 = 拟合误差
            w_bg = (pixel_val - mu_bg) ** 2
            w_fg = (pixel_val - mu_fg) ** 2

            G.add_edge('s', idx, capacity=w_fg)
            G.add_edge(idx, 't', capacity=w_bg)

            # n-links：平滑项
            # 只连接右邻居和下邻居
            if i < H - 1:  # 下邻居
                idx_down = (i + 1) * W + j
                weight = lambda_ * np.exp(-(pixel_val - f[i+1, j])**2)
                G.add_edge(idx, idx_down, capacity=weight)
                G.add_edge(idx_down, idx, capacity=weight)

            if j < W - 1:  # 右邻居
                idx_right = i * W + (j + 1)
                weight = lambda_ * np.exp(-(pixel_val - f[i, j+1])**2)
                G.add_edge(idx, idx_right, capacity=weight)
                G.add_edge(idx_right, idx, capacity=weight)

    # 计算最小割
    cut_value, partition = nx.minimum_cut(G, 's', 't')

    # 提取分割
    reachable, _ = partition
    segmentation = np.zeros((H, W), dtype=np.uint8)

    for i in range(H):
        for j in range(W):
            idx = i * W + j
            if idx in reachable:
                segmentation[i, j] = 1  # 前景
            else:
                segmentation[i, j] = 0  # 背景

    return segmentation
```

---

### 6.2 使用PyMaxflow（更快）

```python
# 需要安装: pip install PyMaxflow
import maxflow
import numpy as np

def graph_cut_segmentation_fast(f, lambda_=1.0):
    """
    使用PyMaxflow的快速图割实现
    """
    H, W = f.shape
    n_pixels = H * W

    # 创建图
    g = maxflow.Graph[float]()
    nodes = g.add_grid_nodes((H, W))

    # 估计均值
    mu_bg = np.mean(f)
    mu_fg = np.mean(f[f > mu_bg])

    # 添加t-links和n-links
    for i in range(H):
        for j in range(W):
            pixel_val = f[i, j]

            # t-links
            w_bg = (pixel_val - mu_bg) ** 2
            w_fg = (pixel_val - mu_fg) ** 2

            g.add_tedge(nodes[i, j], w_fg, w_bg)

            # n-links（只向右和下）
            if i < H - 1:
                weight = lambda_ * np.exp(-(pixel_val - f[i+1, j])**2)
                g.add_edge(nodes[i, j], nodes[i+1, j], weight, weight)

            if j < W - 1:
                weight = lambda_ * np.exp(-(pixel_val - f[i, j+1])**2)
                g.add_edge(nodes[i, j], nodes[i, j+1], weight, weight)

    # 计算最大流
    g.maxflow()

    # 提取分割
    sgm = g.get_grid_segments(nodes)

    return sgm.reshape((H, W)).astype(np.uint8)
```

---

## Part 7: 凸松弛与图割的联系

### 7.1 从连续到离散

**凸松弛**：
```
min ∫|∇u| s.t. u ∈ [0,1]
```
解：u* ∈ [0,1]

**阈值**：
```
L_i = {1, if u_i > 0.5
     {0, if u_i ≤ 0.5
```

**与图割的关系**：
```
在某些条件下，阈值后的解
= 图割的全局最优解
```

---

### 7.2 何时松弛是紧的？

**定理**：
```
如果数据项满足：
D_i(1) - D_i(0) + Σ_j [V_{i,j}(0,1) - V_{i,j}(0,0)] ≠ 0

则凸松弛是紧的，且
阈值化后的解 = 图割解
```

**直观理解**：
```
如果前景和背景足够"不同"
→ 数据项占主导
→ 每个像素的标签"确定"（接近0或1）
→ 松弛自然紧
```

---

## Part 8: 对比实验

### 8.1 方法对比

| 方法 | 优化性质 | 速度 | 全局最优 | 适用场景 |
|:---|:---|:---|:---|:---|
| **图割** | 离散凸 | 快 | ✓ | 二值/多标签 |
| **Chan-Vese** | 非凸 | 中 | ✗ | 两相分割 |
| **Split Bregman** | 凸松弛 | 快 | ✓ | TV正则化 |
| **梯度下降** | 非凸 | 慢 | ✗ | 一般问题 |

### 8.2 选择建议

**使用图割**：
- 二值/多标签分割
- 需要全局最优
- 内存足够

**使用凸松弛**：
- TV正则化问题
- 需要快速收敛
- 内存受限

---

## 课后练习

### 练习1：图构造

给定3×3图像，构造图割的图：

```
图像：
[1 2 1
 2 3 2
 1 2 1]

任务：
1. 估计μ₀, μ₁
2. 计算所有边的容量
3. 画出图的结构
```

### 练习2：代码实现

实现并对比：
1. NetworkX图割
2. PyMaxflow图割
3. Chan-Vese

### 练习3：凸性证明

证明：
1. TV是凸泛函
2. Potts模型是次模的
3. 图割能量是凸的（在离散意义上）

---

## 参考文献深入阅读

1. **Boykov-Kolmogorov (2004)**: 图割算法经典论文
2. **Kolmogorov-Zabih (2004)**: 图割能量函数
3. **Goldstein-Osher (2009)**: Split Bregman方法
4. **Esser et al. (2010)**: 凸松弛理论

---

**下一课预告**：深度学习与变分法的结合
