// Main Application
let currentPage = 'dashboard';
let currentPaper = null;
let charts = {};
let networkInitialized = false;
let timelineInitialized = false;

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing...');
    initNavigation();
    initDashboard();
    initPapersPage();
    initModalEvents();
    
    // å»¶è¿Ÿåˆå§‹åŒ–EChartså›¾è¡¨
    setTimeout(() => {
        if (typeof echarts !== 'undefined') {
            console.log('ECharts loaded, ready to init charts');
        } else {
            console.error('ECharts not available');
        }
    }, 100);
});

// ===== Navigation =====
function initNavigation() {
    const sidebarNav = document.querySelector('.sidebar-nav');
    if (sidebarNav) {
        sidebarNav.addEventListener('click', function(e) {
            const navItem = e.target.closest('.nav-item');
            if (navItem && navItem.getAttribute('data-page')) {
                e.preventDefault();
                const page = navItem.getAttribute('data-page');
                switchPage(page);
            }
        });
    }
    
    const menuToggle = document.getElementById('menuToggle');
    if (menuToggle) {
        menuToggle.addEventListener('click', () => {
            document.getElementById('sidebar').classList.toggle('open');
        });
    }
    
    const globalSearch = document.getElementById('globalSearch');
    if (globalSearch) {
        globalSearch.addEventListener('input', function(e) {
            const query = e.target.value.toLowerCase();
            if (query.length > 2) {
                searchPapers(query);
            }
        });
    }
}

function initModalEvents() {
    const modalClose = document.querySelector('.modal-close');
    if (modalClose) modalClose.addEventListener('click', closeModal);
    
    const modalOverlay = document.querySelector('.modal-overlay');
    if (modalOverlay) modalOverlay.addEventListener('click', closeModal);
    
    const btnReadNote = document.getElementById('btnReadNote');
    if (btnReadNote) btnReadNote.addEventListener('click', openNote);
    
    const btnViewPDF = document.getElementById('btnViewPDF');
    if (btnViewPDF) btnViewPDF.addEventListener('click', openPDF);
}

function switchPage(page) {
    console.log('Switching to page:', page);
    currentPage = page;
    
    // Update nav
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.toggle('active', item.getAttribute('data-page') === page);
    });
    
    // Update title
    const titles = {
        dashboard: 'æ•°æ®ä»ªè¡¨ç›˜',
        papers: 'è®ºæ–‡åˆ—è¡¨',
        network: 'å¼•ç”¨ç½‘ç»œ',
        timeline: 'ç ”ç©¶æ—¶é—´çº¿'
    };
    const pageTitle = document.getElementById('pageTitle');
    if (pageTitle) pageTitle.textContent = titles[page] || '';
    
    // Show/hide pages
    document.querySelectorAll('.page').forEach(p => {
        p.classList.toggle('active', p.id === page);
    });
    
    document.getElementById('sidebar').classList.remove('open');
    
    // Initialize charts when page is shown
    if (page === 'network' && !networkInitialized) {
        setTimeout(initNetworkPage, 100);
    }
    if (page === 'timeline' && !timelineInitialized) {
        setTimeout(initTimelinePage, 100);
    }
    
    // Resize charts
    if (page === 'network' && charts.network) charts.network.resize();
    if (page === 'timeline' && charts.timeline) charts.timeline.resize();
}

// ===== Dashboard =====
function initDashboard() {
    const categoryCtx = document.getElementById('categoryChart');
    if (categoryCtx) {
        charts.category = new Chart(categoryCtx, {
            type: 'doughnut',
            data: {
                labels: Object.keys(PAPERS_DATA.categories),
                datasets: [{
                    data: Object.values(PAPERS_DATA.categories).map(c => c.count),
                    backgroundColor: ['#ef4444', '#3b82f6', '#10b981', '#8b5cf6', '#f59e0b', '#6b7280'],
                    borderWidth: 2, borderColor: '#fff'
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { legend: { position: 'bottom', labels: { usePointStyle: true, padding: 15, font: { size: 11 } } } }
            }
        });
    }
    
    const completionCtx = document.getElementById('completionChart');
    if (completionCtx) {
        charts.completion = new Chart(completionCtx, {
            type: 'pie',
            data: {
                labels: ['å·²å®Œæˆ', 'å¾…å¡«å……'],
                datasets: [{
                    data: [PAPERS_DATA.summary.filled, PAPERS_DATA.summary.templates],
                    backgroundColor: ['#10b981', '#f59e0b'],
                    borderWidth: 2, borderColor: '#fff'
                }]
            },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom' } } }
        });
    }
    
    const progressContainer = document.getElementById('categoryProgress');
    if (progressContainer) {
        Object.entries(PAPERS_DATA.categories).forEach(([name, data]) => {
            const percentage = (data.filled / data.count * 100).toFixed(1);
            const color = Utils.getCategoryColor(name);
            const item = document.createElement('div');
            item.className = 'progress-item';
            item.innerHTML = `
                <div class="progress-item-header">
                    <span class="progress-label"><span class="progress-color-dot" style="background:${color}"></span>${name}</span>
                    <span class="progress-value">${data.filled}/${data.count} (${percentage}%)</span>
                </div>
                <div class="progress-bar"><div class="progress-fill" style="width:0%;background:${color}"></div></div>
            `;
            progressContainer.appendChild(item);
            setTimeout(() => item.querySelector('.progress-fill').style.width = percentage + '%', 300);
        });
    }
}

// ===== Papers Page =====
let filteredPapers = [...PAPERS_DATA.papers];
let currentPageNum = 1;
const itemsPerPage = 12;

function initPapersPage() {
    document.getElementById('categoryFilter')?.addEventListener('change', filterPapers);
    document.getElementById('statusFilter')?.addEventListener('change', filterPapers);
    document.getElementById('sortFilter')?.addEventListener('change', filterPapers);
    filterPapers();
}

function filterPapers() {
    let papers = [...PAPERS_DATA.papers];
    
    const category = document.getElementById('categoryFilter')?.value;
    if (category && category !== 'all') papers = papers.filter(p => p.category === category);
    
    const status = document.getElementById('statusFilter')?.value;
    if (status && status !== 'all') papers = papers.filter(p => p.status === status);
    
    const sortBy = document.getElementById('sortFilter')?.value || 'id';
    papers.sort((a, b) => {
        if (sortBy === 'year') return (b.year || 0) - (a.year || 0);
        if (sortBy === 'category') return a.category.localeCompare(b.category);
        return a.id.localeCompare(b.id);
    });
    
    filteredPapers = papers;
    currentPageNum = 1;
    renderPapers();
}

function renderPapers() {
    const grid = document.getElementById('papersGrid');
    if (!grid) return;
    
    const start = (currentPageNum - 1) * itemsPerPage;
    const pagePapers = filteredPapers.slice(start, start + itemsPerPage);
    
    grid.innerHTML = pagePapers.map(paper => `
        <div class="paper-card ${Utils.getCategoryClass(paper.category)}" onclick='openPaperModal(${JSON.stringify(paper).replace(/'/g, "&#39;")})'>
            <div class="paper-card-header">
                <span class="paper-id-badge">[${paper.id}]</span>
                <span class="paper-status ${paper.status}">${paper.status === 'filled' ? 'âœ“' : 'â—‹'}</span>
            </div>
            <div class="paper-title">${paper.title}</div>
            <div class="paper-footer">
                <span class="badge ${Utils.getCategoryClass(paper.category)}">${paper.category}</span>
                <span class="paper-year">${paper.year}</span>
            </div>
        </div>
    `).join('');
    
    renderPagination();
}

function renderPagination() {
    const container = document.getElementById('pagination');
    if (!container) return;
    
    const totalPages = Math.ceil(filteredPapers.length / itemsPerPage);
    if (totalPages <= 1) { container.innerHTML = ''; return; }
    
    container.innerHTML = Array.from({length: totalPages}, (_, i) => 
        `<button class="page-btn ${i + 1 === currentPageNum ? 'active' : ''}" onclick="currentPageNum=${i+1};renderPapers()">${i+1}</button>`
    ).join('');
}

function searchPapers(query) {
    switchPage('papers');
    filteredPapers = PAPERS_DATA.papers.filter(p => 
        p.title.toLowerCase().includes(query) || p.id.toLowerCase().includes(query)
    );
    currentPageNum = 1;
    renderPapers();
}

// ===== Modal =====
function openPaperModal(paper) {
    currentPaper = paper;
    document.getElementById('modalPaperId').textContent = `[${paper.id}]`;
    document.getElementById('modalPaperTitle').textContent = paper.title;
    document.getElementById('modalPaperCategory').textContent = paper.category;
    document.getElementById('modalPaperCategory').className = `badge ${Utils.getCategoryClass(paper.category)}`;
    document.getElementById('modalPaperYear').textContent = paper.year;
    document.getElementById('modalPaperStatus').textContent = paper.status === 'filled' ? 'âœ“ å·²å®Œæˆ' : 'â—‹ å¾…å¡«å……';
    document.getElementById('modalPaperStatus').className = `badge ${paper.status === 'filled' ? 'success' : 'warning'}`;
    document.getElementById('notePreview').innerHTML = '<div class="placeholder" style="text-align:center;padding:4rem 2rem"><div style="font-size:3rem;margin-bottom:1rem">ğŸ“–</div><p>ç‚¹å‡»ä¸Šæ–¹"æŸ¥çœ‹ç²¾è¯»ç¬”è®°"åŠ è½½å†…å®¹</p></div>';
    
    const hasNote = paper.noteFile && paper.noteFile.trim() !== '';
    const btnReadNote = document.getElementById('btnReadNote');
    btnReadNote.disabled = !hasNote;
    btnReadNote.style.opacity = hasNote ? '1' : '0.5';
    
    const hasPDF = paper.pdfFile && paper.pdfFile.trim() !== '';
    const btnViewPDF = document.getElementById('btnViewPDF');
    btnViewPDF.disabled = !hasPDF;
    btnViewPDF.style.opacity = hasPDF ? '1' : '0.5';
    
    document.getElementById('paperModal').classList.add('active');
}

function closeModal() {
    document.getElementById('paperModal').classList.remove('active');
    currentPaper = null;
}

async function openNote() {
    if (!currentPaper || !currentPaper.noteFile) return;
    const preview = document.getElementById('notePreview');
    preview.innerHTML = '<div class="placeholder" style="padding:3rem">åŠ è½½ä¸­...</div>';
    
    try {
        const response = await fetch(Utils.getNotePath(currentPaper.noteFile));
        if (!response.ok) throw new Error('Failed');
        const markdown = await response.text();
        const html = typeof marked !== 'undefined' && marked.parse ? marked.parse(markdown) : markdown.replace(/\n/g, '<br>');
        preview.innerHTML = `<div class="markdown-body" id="markdownContent">${html}</div>`;
    } catch (err) {
        preview.innerHTML = `<div style="padding:1.5rem;background:#fef3c7;border-radius:8px"><p><strong>âš ï¸ æ— æ³•åŠ è½½ç¬”è®°</strong></p><p>${err.message}</p></div>`;
    }
}

function openPDF() {
    if (!currentPaper || !currentPaper.pdfFile) { alert('è¯¥è®ºæ–‡æš‚æ— PDFæ–‡ä»¶'); return; }
    window.open('/00_papers/' + encodeURIComponent(currentPaper.pdfFile), '_blank');
}

// ===== Network Page =====
function initNetworkPage() {
    console.log('initNetworkPage called');
    if (networkInitialized) return;
    
    const chartDom = document.getElementById('networkChart');
    if (!chartDom) { console.error('networkChart not found'); return; }
    
    if (typeof echarts === 'undefined') {
        chartDom.innerHTML = '<div style="padding:40px;text-align:center"><h3>âš ï¸ EChartsåŠ è½½å¤±è´¥</h3><p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ååˆ·æ–°é¡µé¢</p></div>';
        return;
    }
    
    try {
        charts.network = echarts.init(chartDom);
        networkInitialized = true;
        
        const categoryColors = { "åŸºç¡€ç†è®º": "#ef4444", "å˜åˆ†åˆ†å‰²": "#3b82f6", "æ·±åº¦å­¦ä¹ ": "#10b981", "é›·è¾¾ä¸æ— çº¿ç”µ": "#8b5cf6", "åŒ»å­¦å›¾åƒ": "#f59e0b", "å…¶ä»–": "#6b7280" };
        const categoryList = ["åŸºç¡€ç†è®º", "å˜åˆ†åˆ†å‰²", "æ·±åº¦å­¦ä¹ ", "é›·è¾¾ä¸æ— çº¿ç”µ", "åŒ»å­¦å›¾åƒ", "å…¶ä»–"];
        
        // Create categories array for legend
        const categories = categoryList.map(name => ({ name }));
        
        // Create nodes - remove category index, use color directly
        const nodes = PAPERS_DATA.papers.map(paper => ({
            id: paper.id, 
            name: paper.title.substring(0, 12) + '...',
            value: paper.id,
            symbolSize: paper.status === 'filled' ? 20 : 12,
            itemStyle: { color: categoryColors[paper.category] },
            label: { show: true, fontSize: 9 },
            paper: paper
        }));
        
        // Filter valid links (both source and target must exist)
        const validIds = new Set(nodes.map(n => n.id));
        const links = PAPERS_DATA.citations
            .filter(c => validIds.has(c.source) && validIds.has(c.target))
            .map(c => ({ source: c.source, target: c.target, value: c.strength }));
        
        charts.network.setOption({
            tooltip: {
                trigger: 'item',
                formatter: params => params.dataType === 'node' ? 
                    `<strong>[${params.data.paper.id}]</strong><br/>${params.data.paper.title}<br/>${params.data.paper.category} | ${params.data.paper.year}` :
                    `${params.data.source} â†’ ${params.data.target}`
            },
            legend: { data: categoryList, bottom: 10 },
            series: [{
                type: 'graph', 
                layout: 'force', 
                data: nodes, 
                links: links,
                categories: categories,
                roam: true, 
                draggable: true,
                label: { show: true, position: 'bottom', fontSize: 9 },
                force: { repulsion: 600, gravity: 0.1, edgeLength: 100 },
                lineStyle: { color: 'source', curveness: 0.2, opacity: 0.6, width: 2 }
            }]
        });
        
        charts.network.on('click', params => { 
            if (params.dataType === 'node') openPaperModal(params.data.paper); 
        });
        
        console.log('Network chart initialized successfully');
    } catch (e) {
        console.error('Network init failed:', e);
        chartDom.innerHTML = `<div style="padding:40px;text-align:center;color:red"><h3>å›¾è¡¨åˆå§‹åŒ–å¤±è´¥</h3><p>${e.message}</p></div>`;
    }
}

// ===== Timeline Page =====
function initTimelinePage() {
    console.log('initTimelinePage called');
    if (timelineInitialized) return;
    
    const chartDom = document.getElementById('timelineChart');
    if (!chartDom) { console.error('timelineChart not found'); return; }
    
    if (typeof echarts === 'undefined') {
        chartDom.innerHTML = '<div style="padding:40px;text-align:center"><h3>âš ï¸ EChartsåŠ è½½å¤±è´¥</h3><p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ååˆ·æ–°é¡µé¢</p></div>';
        return;
    }
    
    try {
        charts.timeline = echarts.init(chartDom);
        timelineInitialized = true;
        
        const categoryColors = { "åŸºç¡€ç†è®º": "#ef4444", "å˜åˆ†åˆ†å‰²": "#3b82f6", "æ·±åº¦å­¦ä¹ ": "#10b981", "é›·è¾¾ä¸æ— çº¿ç”µ": "#8b5cf6", "åŒ»å­¦å›¾åƒ": "#f59e0b", "å…¶ä»–": "#6b7280" };
        
        const sortedPapers = [...PAPERS_DATA.papers].filter(p => p.year && p.year !== 'unknown').sort((a, b) => parseInt(a.year) - parseInt(b.year));
        const years = [...new Set(sortedPapers.map(p => p.year))].sort();
        
        const seriesData = sortedPapers.map((paper, index) => ({
            value: [years.indexOf(paper.year), index],
            paper: paper,
            itemStyle: { color: categoryColors[paper.category] },
            symbolSize: 12
        }));
        
        charts.timeline.setOption({
            tooltip: {
                trigger: 'item',
                formatter: params => {
                    const p = params.data.paper;
                    return `<strong>[${p.id}] ${p.year}</strong><br/>${p.title}<br/><span style="color:${categoryColors[p.category]}">â—</span> ${p.category}`;
                }
            },
            grid: { left: '5%', right: '40%', bottom: '10%', top: '5%' },
            xAxis: { 
                type: 'category', 
                data: years, 
                name: 'å¹´ä»½', 
                nameLocation: 'middle', 
                nameGap: 30,
                axisLabel: { fontSize: 12 },
                axisLine: { lineStyle: { color: '#999' } },
                splitLine: { show: true, lineStyle: { type: 'dashed', color: '#e0e0e0' } }
            },
            yAxis: { type: 'value', show: false },
            series: [{ 
                type: 'scatter', 
                data: seriesData
            }]
        });
        
        charts.timeline.on('click', params => { 
            if (params.data && params.data.paper) openPaperModal(params.data.paper); 
        });
        
        // Filter buttons
        document.querySelectorAll('.timeline-filters .filter-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.timeline-filters .filter-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                const filter = this.dataset.filter;
                const filtered = filter === 'all' ? sortedPapers : sortedPapers.filter(p => p.category === filter);
                charts.timeline.setOption({ 
                    series: [{ 
                        data: filtered.map((p, i) => ({
                            value: [years.indexOf(p.year), i],
                            paper: p,
                            itemStyle: { color: categoryColors[p.category] },
                            symbolSize: 12
                        })) 
                    }]
                });
            });
        });
        
        console.log('Timeline chart initialized successfully');
    } catch (e) {
        console.error('Timeline init failed:', e);
        chartDom.innerHTML = `<div style="padding:40px;text-align:center;color:red"><h3>å›¾è¡¨åˆå§‹åŒ–å¤±è´¥</h3><p>${e.message}</p></div>`;
    }
}

window.addEventListener('resize', () => Object.values(charts).forEach(c => c && c.resize && c.resize()));
