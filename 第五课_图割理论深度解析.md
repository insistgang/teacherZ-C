# 第五课：图割理论深度解析

> **目标**: 深入理解图割的数学原理和算法实现
> **难度**: ⭐⭐⭐⭐⭐ (需要组合优化基础)
> **价值**: ⭐⭐⭐⭐⭐ (工业界广泛使用)

---

## Part 1: 图论基础

### 1.1 流网络的基本概念

**流网络 (Flow Network)**：

定义为一个有向图 G = (V, E)，其中：
- **V**: 顶点集合
- **E**: 边集合
- **c: E → ℝ⁺**: 容量函数（每条边的最大流量）
- **s ∈ V**: 源点 (source)
- **t ∈ V**: 汇点 (sink)

**示例**：
```
    s ────10───► a ────5───► t
    │           │           ▲
    └───5───►   │           │
               b ────10────┘
```

---

### 1.2 流 (Flow) 的定义

**流** 是一个函数 f: E → ℝ，满足：

**1. 容量约束**：
```
0 ≤ f(u,v) ≤ c(u,v),  ∀(u,v) ∈ E
```
流量不能超过边的容量

**2. 流守恒**：
```
Σ_{v:(u,v)∈E} f(u,v) = Σ_{v:(v,u)∈E} f(v,u),  ∀u ∈ V \ {s,t}
```
对于中间节点，流入 = 流出

**3. 流的值**：
```
|f| = Σ_{v:(s,v)∈E} f(s,v) - Σ_{v:(v,s)∈E} f(v,s)
```
从源点流出的净流量

---

### 1.3 割 (Cut) 的定义

**s-t割**：将顶点分为两个集合
```
S ⊂ V, T = V \ S
满足 s ∈ S, t ∈ T
```

**割的容量**：
```
c(S,T) = Σ_{u∈S, v∈T} c(u,v)
```
所有从S到T的边的容量之和

**最小割问题**：
```
min c(S,T)
s.t. s ∈ S, t ∈ T
```

---

## Part 2: 最大流最小割定理

### 2.1 定理陈述

**定理**（Ford-Fulkerson, 1956）：
```
max flow = min cut
```

**意义**：
- 最大流的值 = 最小割的容量
- 这是一个强对偶定理
- 提供了求解最小割的方法（通过最大流）

---

### 2.2 定理证明（构造性）

**关键概念：残量网络 (Residual Network)**

**定义**：给定流 f，残量网络 G_f 包含边：
```
如果 f(u,v) < c(u,v):
    添加前向边 (u,v)，容量 c_f(u,v) = c(u,v) - f(u,v)

如果 f(u,v) > 0:
    添加后向边 (v,u)，容量 c_f(v,u) = f(u,v)
```

**增广路径 (Augmenting Path)**：
```
在残量网络中从s到t的路径
可以沿此路径增加流量
```

---

### 2.3 Ford-Fulkerson算法

**算法**：
```
1. 初始化：f(e) = 0 对所有边e
2. while 存在增广路径P in G_f:
     3. 计算增广量 Δ = min_{(u,v)∈P} c_f(u,v)
     4. 对所有(u,v)∈P:
         如果(u,v)是前向边: f(u,v) += Δ
         如果(u,v)是后向边: f(u,v) -= Δ
5. return f
```

**终止**：当不存在增广路径时

**正确性**：当算法终止时，已达到最大流

---

### 2.4 示例：手动计算

**示例网络**：
```
    s ────3───► a ────2───► t
    │           ▲           ▲
    └───2───►   │           │
               b ────3────┘
```

**步骤1：初始流**
```
f = 0 (所有边)
```

**步骤2：找增广路径**
```
路径1: s → a → t
增量: Δ = min(3, 2) = 2

更新流:
f(s,a) = 2, f(a,t) = 2
```

**步骤3：找增广路径**
```
路径2: s → b → t
增量: Δ = min(2, 3) = 2

更新流:
f(s,b) = 2, f(b,t) = 2
```

**步骤4：找增广路径**
```
路径3: s → a → b → t
残量容量:
  s→a: 3-2=1
  a→b: ∞ (反向边，流量=2)
  b→t: 3-2=1

增量: Δ = min(1, 2, 1) = 1

更新流:
f(s,a) = 2+1 = 3
f(b,a) = 2  (反向)
f(b,t) = 2+1 = 3
```

**步骤5：无增广路径**
```
最大流 = 2 + 2 + 1 = 5
```

**验证最小割**：
```
割: S={s,a}, T={b,t}
容量 = c(a,t) + c(s,b) = 2 + 3 = 5 ✓
```

---

## Part 3: 次模性 (Submodularity)

### 3.1 次模函数的定义

**集合函数**：f: 2^V → ℝ

**次模性**：
```
对所有 A, B ⊆ V:
f(A) + f(B) ≥ f(A ∪ B) + f(A ∩ B)
```

**等价定义（边际收益递减）**：
```
对所有 A ⊆ B 和 x ∉ B:
f(A ∪ {x}) - f(A) ≥ f(B ∪ {x}) - f(B)
```

**直观理解**：
- 边际收益递减
- 多一个元素的增加量递减
- 类似于凸函数的离散版本

---

### 3.2 次模性与图割的关系

**关键定理**：
```
如果能量函数 E(L) 是次模的
→ 可以用图割最小化
→ 全局最优解可通过最大流获得
```

**为什么？**
```
次模性保证：
- 局部极小值 = 全局极小值
- 没有多个局部极小值
- 可以用贪婪算法或图割求解
```

---

### 3.3 图割能量是次模的吗？

**能量**：
```
E(L) = Σ_i D_i(L_i) + Σ_{i,j} V_{i,j}(L_i, L_j)
```

**数据项**：D_i(L_i) 是次模的（单点函数）

**平滑项**：V_{i,j}(L_i, L_j)

**Potts模型**：
```
V_{i,j}(L_i, L_j) = {λ,  if L_i ≠ L_j
                   {0,  if L_i = L_j
```

**验证次模性**：
```
对于两标签问题 {0,1}:

考虑四种情况:
1. L_i = 0, L_j = 0: V = 0
2. L_i = 0, L_j = 1: V = λ
3. L_i = 1, L_j = 0: V = λ
4. L_i = 1, L_j = 1: V = 0

定义: f(L_i, L_j) = V(L_i, L_j)

验证: f(00) + f(11) ≥ f(01) + f(10)
       0    +   0   ≥  λ  +   λ
       0 ≥ 2λ  ❌ (如果λ > 0)
```

**等等！这不满足次模性！**

---

### 3.4 规则化（Regularization）

**技巧**：添加常数项使其次模

**定义**：
```
E'(L) = E(L) + Σ_{i,j} K
```
其中K是足够大的常数

**关键**：常数项不影响优化结果！
```
argmin E(L) = argmin E'(L)
```

**另一种方法**：重新参数化

**定义新的平滑项**：
```
V'_{i,j}(L_i, L_j) = w_{i,j} · [L_i ≠ L_j]
```

选择适当的w_{i,j}使其次模

---

## Part 4: 图割构造详解

### 4.1 一般的能量函数

**形式**：
```
E(L) = Σ_i D_i(L_i) + Σ_{i,j} V_{i,j}(L_i, L_j)
```

**数据项**：D_i(L_i) = 单个像素i取标签L_i的代价

**平滑项**：V_{i,j}(L_i, L_j) = 像素i,j取不同标签的惩罚

---

### 4.2 二值分割的图构造

**问题**：每个像素标签 ∈ {0, 1}

**图构造**：

**顶点**：
```
V = {s} ∪ {t} ∪ {1, 2, ..., n}
```
其中n是像素数，s是源点，t是汇点

**边**：

**1. t-links（终端边）**：
```
对于每个像素i:
  c(s, i) = D_i(1)  # i取标签1的代价
  c(i, t) = D_i(0)  # i取标签0的代价
```

**2. n-links（邻接边）**：
```
对于相邻像素i, j:
  c(i, j) = V_{i,j}(0, 1)
  c(j, i) = V_{i,j}(0, 1)
```

**关键**：双向边，容量相同

---

### 4.3 割与标签的对应

**定理**：
```
设(S, T)是最小割
定义标签:
  L_i = 1 if i ∈ S
  L_i = 0 if i ∈ T

则L是最小能量函数
```

**证明**：

**割的容量**：
```
c(S,T) = Σ_{i∈S} c(s,i) + Σ_{i∈T} c(i,t)
         + Σ_{i∈S, j∈T} c(i,j)
```

**代入边容量**：
```
= Σ_{i: L_i=1} D_i(1) + Σ_{i: L_i=0} D_i(0)
  + Σ_{i,j: L_i=1, L_j=0} V_{i,j}(0, 1)

= Σ_i D_i(L_i) + Σ_{i,j: L_i≠L_j} V_{i,j}(L_i, L_j)

= E(L)
```

**因此**：最小割 → 最小能量 ✓

---

### 4.4 多标号问题

**问题**：标签 L_i ∈ {0, 1, ..., K-1}

**挑战**：
```
直接扩展需要:
├── K-1个源点？
├── 多项式复杂度的边？
└── 不一定次模
```

**解决方案1：α-扩展 (α-Expansion)**

**思想**：每次只考虑两个标签

**算法**：
```
1. 初始化标签 L
2. repeat:
     3. 选择标签α ∈ {0, ..., K-1}
     4. 对每个像素i:
         固定其他标签，只允许 L_i ∈ {当前值, α}
     5. 用图割求解这个二值问题
   6. until 收敛
```

**保证**：每次迭代不增加能量

**解决方案2：交换 (Swap)**

**思想**：每次只交换一对标签

---

## Part 5: 高级算法

### 5.1 Push-Relabel算法

**优于Ford-Fulkerson的地方**：
- 不需要找增广路径
- 更实用，更快
- O(V³) 时间

**核心思想**：
```
1. 维护每个顶点的"高度" h(v)
2. 如果有流量可以推送，推送
3. 否则，提升顶点高度
```

**高度函数性质**：
```
h(s) = |V|
h(t) = 0
对其他v: 0 ≤ h(v) ≤ |V|
```

---

### 5.2 Boykov-Kolmogorov算法

**专门为图割设计的算法**

**核心思想**：
```
1. 同时维护两个搜索树
2. 从源点出发的树（S树）
3. 从汇点出发的树（T树）
4. 当树相遇时找到路径
```

**优势**：
- 在计算机视觉问题上非常快
- 充分利用了图结构的特殊性
- O(V²√E) 最坏情况，实际更快

---

### 5.3 并行算法

**现代GPU实现**：
```
并行计算：
- 多个增广路径
- 多个流的合并
- GPU上的大规模图割
```

**库**：
- NVIDIA CUDA Max-Flow
- PyMaxflow (Python绑定)

---

## Part 6: 3D图割

### 6.1 3D图像的图构造

**顶点**：
```
V = {s, t} ∪ {所有体素 (voxels)}
```

**边**：
```
1. t-links: 每个体素连接到s和t

2. n-links: 6-邻域或26-邻域
   - 上下前后左右
   - 或包括对角线
```

**复杂度**：
```
对于N×N×N的3D图像:
- 顶点数: O(N³)
- 边数: O(N³)

内存和计算量都很大！
```

---

### 6.2 立体匹配应用

**问题**：从两幅图像重建3D

**视能图 (Disparity Map)**：
```
每个像素的视能 d ∈ [d_min, d_max]

能量:
E(d) = 数据项 + 平滑项

数据项: 匹配误差
平滑项: 视能连续性
```

**图割求解**：
```
每个像素的视能看作标签
用α-扩展算法
```

---

## Part 7: 完整代码实现

### 7.1 手动实现Ford-Fulkerson

```python
class GraphCut:
    """图割的简单实现"""

    def __init__(self, n_nodes):
        """初始化图（n_nodes不包括s和t）"""
        self.n = n_nodes
        self.capacity = {}  # 容量矩阵

    def add_edge(self, u, v, cap):
        """添加边"""
        if (u, v) not in self.capacity:
            self.capacity[(u, v)] = 0
            self.capacity[(v, u)] = 0  # 反向边
        self.capacity[(u, v)] += cap

    def max_flow(self, s, t):
        """Ford-Fulkerson算法"""
        flow = 0
        parent = {}

        # BFS找增广路径
        while self._bfs(s, t, parent):
            # 计算增广量
            path_flow = float('Inf')
            v = t
            while v != s:
                u = parent[v]
                path_flow = min(path_flow,
                               self.capacity[(u, v)] -
                               self.flow.get((u, v), 0))
                v = u

            # 更新流量
            v = t
            while v != s:
                u = parent[v]
                self.flow[(u, v)] = self.flow.get((u, v), 0) + path_flow
                self.flow[(v, u)] = self.flow.get((v, u), 0) - path_flow
                v = u

            flow += path_flow

        return flow

    def _bfs(self, s, t, parent):
        """BFS寻找增广路径"""
        visited = {s}
        queue = [s]

        while queue:
            u = queue.pop(0)

            for v in range(self.n):
                if v == s:
                    continue

                # 检查前向边
                if (u, v) in self.capacity:
                    residual = self.capacity[(u, v)] - self.flow.get((u, v), 0)
                    if residual > 0 and v not in visited:
                        visited.add(v)
                        parent[v] = u
                        queue.append(v)
                        if v == t:
                            return True

        return False

    def get_cut(self, s):
        """获取割（从最大流）"""
        # 从s出发的BFS
        reachable = set()
        queue = [s]
        visited = {s}

        while queue:
            u = queue.pop(0)
            reachable.add(u)

            for v in range(self.n):
                if v in visited:
                    continue

                # 检查残量边
                if (u, v) in self.capacity:
                    residual = self.capacity[(u, v)] - self.flow.get((u, v), 0)
                    if residual > 0:
                        visited.add(v)
                        queue.append(v)

        return reachable
```

---

### 7.2 使用PyMaxflow（推荐）

```python
import maxflow
import numpy as np

def graph_cut_2d(image, lambda_=1.0):
    """
    使用PyMaxflow进行2D图像分割

    Parameters:
    -----------
    image : ndarray
        输入灰度图像
    lambda_ : float
        平滑参数

    Returns:
    --------
    segmentation : ndarray
        分割结果（0/1）
    """
    H, W = image.shape

    # 创建图
    g = maxflow.Graph[float]()
    nodeids = g.add_grid_nodes((H, W))

    # 添加t-links
    # 估计前景和背景
    threshold = np.mean(image)
    mu_bg = np.mean(image[image < threshold])
    mu_fg = np.mean(image[image > threshold])

    for i in range(H):
        for j in range(W):
            # 数据项
            w_bg = (image[i,j] - mu_bg) ** 2
            w_fg = (image[i,j] - mu_fg) ** 2

            g.add_tedge(nodeids[i,j], w_fg, w_bg)

    # 添加n-links
    structure = np.array([[0, 1, 0],
                          [1, 0, 1],
                          [0, 1, 0]])

    weights = np.zeros((3, 3))
    weights[0, 1] = lambda_
    weights[1, 0] = lambda_
    weights[1, 2] = lambda_
    weights[2, 1] = lambda_

    g.add_grid_edges(nodeids, weights=weights, structure=structure,
                     symmetric=True)

    # 计算最大流
    g.maxflow()

    # 获取分割
    sgm = g.get_grid_segments(nodeids)

    return sgm.reshape((H, W))
```

---

### 7.3 3D图割实现

```python
def graph_cut_3d(volume, lambda_=1.0):
    """
    使用PyMaxflow进行3D体分割

    Parameters:
    -----------
    volume : ndarray (D, H, W)
        输入3D体数据
    lambda_ : float
        平滑参数

    Returns:
    --------
    segmentation : ndarray (D, H, W)
        分割结果
    """
    D, H, W = volume.shape

    # 创建图
    g = maxflow.Graph[float]()
    nodeids = g.add_grid_nodes((D, H, W))

    # 添加t-links
    threshold = np.mean(volume)
    mu_bg = np.mean(volume[volume < threshold])
    mu_fg = np.mean(volume[volume > threshold])

    for d in range(D):
        for h in range(H):
            for w in range(W):
                w_bg = (volume[d,h,w] - mu_bg) ** 2
                w_fg = (volume[d,h,w] - mu_fg) ** 2

                g.add_tedge(nodeids[d,h,w], w_fg, w_bg)

    # 添加n-links（6-邻域）
    # 邻域结构
    structure = np.zeros((3, 3, 3), dtype=np.int32)
    structure[1, 1, 0] = 1  # x方向
    structure[1, 0, 1] = 1  # y方向
    structure[0, 1, 1] = 1  # z方向

    weights = np.zeros((3, 3, 3))
    weights[1, 1, 0] = lambda_
    weights[1, 0, 1] = lambda_
    weights[0, 1, 1] = lambda_

    g.add_grid_edges(nodeids, weights=weights, structure=structure,
                     symmetric=True)

    # 计算最大流
    g.maxflow()

    # 获取分割
    sgm = g.get_grid_segments(nodeids)

    return sgm.reshape((D, H, W))
```

---

## Part 8: 理论分析

### 8.1 计算复杂度

**最大流问题**：

| 算法 | 时间复杂度 | 适用场景 |
|:---|:---:|:---|
| Ford-Fulkerson | O(E · max|f|) | 小规模 |
| Edmonds-Karp | O(VE²) | 中等规模 |
| Push-Relabel | O(V³) | 大规模 |
| Boykov-Kolmogorov | O(V²√E) | 图像分割 |

**实际性能**：
```
对于N×N图像:
- 顶点: V = N² + 2
- 边: E ≈ 4N²

Boykov-Kolmogorov: O(N⁴ · √N) = O(N^(4.5))
实际: 几乎线性！
```

---

### 8.2 内存复杂度

**存储图**：
```
顶点: O(V)
边:   O(E)

对于N×N图像:
V = O(N²)
E = O(N²)

总内存: O(N²)
```

**问题**：3D图割
```
对于N×N×N体数据:
V = O(N³)
E = O(N³)

内存: O(N³) - 非常大！
```

**解决方案**：
- 分割处理
- 压缩图结构
- 使用稀疏表示

---

## 课后练习

### 练习1：手算最大流

给定网络：
```
    s
   / \
  10   8
 /     \
a       b
 \     /
  5     7
   \   /
     t
```

任务：
1. 用Ford-Fulkerson算法求最大流
2. 找到最小割
3. 验证 max flow = min cut

### 练习2：验证次模性

能量函数：
```
E(L) = Σ_i D_i(L_i) + Σ_{i,j} V_{i,j}(L_i, L_j)

其中:
D_i(0) = a_i, D_i(1) = b_i
V_{i,j}(0, 0) = 0
V_{i,j}(1, 1) = 0
V_{i,j}(0, 1) = V_{i,j}(1, 0) = w_{i,j}
```

任务：
1. 验证这个能量是否次模
2. 如果不次模，如何修正？
3. 构造对应的图

### 练习3：实现α-扩展

实现多标签分割的α-扩展算法：
```python
def alpha_expansion(image, labels, lambda_):
    """
    α-扩展算法

    Parameters:
    -----------
    image : ndarray
        输入图像
    labels : list
        标签集合 [0, 1, ..., K-1]
    lambda_ : float
        平滑参数

    Returns:
    --------
    segmentation : ndarray
        最优标签
    """
    # 初始化
    L = np.random.choice(labels, size=image.shape)

    # 对每个α
    for alpha in labels:
        # 构造二值图割问题
        # 只允许 L_i ∈ {当前值, alpha}

        # 求解

        # 更新标签

    return L
```

---

## 参考文献深入阅读

1. **Ford & Fulkerson (1962)**: "Flows in Networks"
   - 最大流最小割定理的原始证明

2. **Boykov & Kolmogorov (2004)**: "An Experimental Comparison..."
   - 现代图割算法的详细比较

3. **Kolmogorov & Zabih (2004)**: "What Energy Functions..."
   - 哪些能量可以用图割优化

4. **Veksler (1999)**: "Graph Cut Based Optimization..."
   - 多标签问题的图割方法

---

**下一课预告**：深度学习 + 变分法 - 现代图像分割
