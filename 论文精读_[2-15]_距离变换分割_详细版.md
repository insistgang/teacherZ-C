# 论文精读（超详细版）：[2-15] 距离变换分割

> **论文标题**: Multiclass Segmentation with Distance Transform Constraints  
> **期刊**: IEEE Transactions on Pattern Analysis and Machine Intelligence, 2018  
> **作者**: Xiaohao Cai, et al.  
> **精读深度**: ⭐⭐⭐⭐⭐（水平集+距离函数+几何约束）

---

## 一、问题背景：几何约束的重要性

### 1.1 TV正则化的局限

**TV（总变差）正则化**：
$$TV(u) = \int_\Omega |\nabla u| dx$$

**作用**：
- 鼓励分段常数
- 保边去噪

**不足**：
- 只关心边界长度，不关心形状
- 可能产生锯齿状边界
- 不保持拓扑结构

### 1.2 例子

```
真实边界: 平滑圆
TV分割结果: 多边形近似（锯齿）

问题: 几何不准确，曲率不连续
```

### 1.3 距离变换的引入

**思想**：
用**符号距离函数**（Signed Distance Function, SDF）表示边界，直接控制几何。

**优势**：
- 隐式表示边界
- 可直接计算曲率
- 保持拓扑

---

## 二、符号距离函数（SDF）

### 2.1 定义

设 $\Gamma$ 是区域边界，$\Omega^-$ 是内部，$\Omega^+$ 是外部。

**SDF定义**：
$$\phi(x) = \begin{cases}
-d(x, \Gamma) & x \in \Omega^- \\
0 & x \in \Gamma \\
+d(x, \Gamma) & x \in \Omega^+
\end{cases}$$

其中 $d(x, \Gamma) = \min_{y \in \Gamma} |x - y|$ 是到边界的距离。

### 2.2 性质

**性质1**：零水平集是边界
$$\Gamma = \{x : \phi(x) = 0\}$$

**性质2**：梯度模为1（几乎处处）
$$|\nabla \phi| = 1$$

**性质3**：曲率计算
$$\kappa = \nabla \cdot \left(\frac{\nabla \phi}{|\nabla \phi|}\right) = \Delta \phi$$
（在$|\nabla \phi| = 1$时）

### 2.3 几何意义

| 概念 | 数学表达 | 意义 |
|:---|:---|:---|
| 边界位置 | $\phi = 0$ | 零水平集 |
| 法向量 | $\nabla \phi$ | 指向外部 |
| 曲率 | $\text{div}(\nabla \phi / |\nabla \phi|)$ | 边界弯曲程度 |

---

## 三、基于SDF的分割模型

### 3.1 能量泛函

$$E(\phi) = \underbrace{\int_\Omega g(x) \delta(\phi) |\nabla \phi| dx}_{\text{边界项}} + \underbrace{\int_\Omega (|\nabla \phi| - 1)^2 dx}_{\text{SDF约束}} + \underbrace{\int_\Omega \lambda f(x) H(-\phi) dx}_{\text{区域项}}$$

**各项详解**：

**1. 边界项**：
- $\delta(\phi)$：Dirac delta，只在边界有值
- $g(x) = \frac{1}{1 + |\nabla f|^2}$：边缘指示器（边缘处小）
- 鼓励边界位于图像边缘

**2. SDF约束**：
- $(|\nabla \phi| - 1)^2$：惩罚偏离SDF性质
- 保持$\phi$为距离函数

**3. 区域项**：
- $H(-\phi)$：Heaviside函数，内部为1
- $f(x)$：区域统计信息

### 3.2 多类扩展

**多个SDF**：
- 第 $k$ 类的SDF：$\phi_k$
- 第 $k$ 类区域：$\{x : \phi_k(x) < 0\}$

**多类能量**：
$$E(\{\phi_k\}) = \sum_{k=1}^K \left[ \int g \delta(\phi_k) |\nabla \phi_k| + \mu (|\nabla \phi_k| - 1)^2 + \lambda \int f_k H(-\phi_k) \right]$$

**约束**：
- 区域不重叠：$\Omega_i \cap \Omega_j = \emptyset$
- 覆盖全图：$\bigcup_k \Omega_k = \Omega$

---

## 四、水平集演化算法

### 4.1 梯度下降

**Euler-Lagrange方程**：
$$\frac{\partial \phi}{\partial t} = \delta(\phi) \left[ \text{div}\left(g \frac{\nabla \phi}{|\nabla \phi|}\right) + \lambda f \right] + \mu \left(\Delta \phi - \text{div}\left(\frac{\nabla \phi}{|\nabla \phi|}\right)\right)$$

**各项物理意义**：
- $\text{div}(g \frac{\nabla \phi}{|\nabla \phi|})$：曲率流（平滑）
- $g$：在边缘处减速
- $\lambda f$：区域力（扩张/收缩）
- $\mu$项：保持SDF性质

### 4.2 数值实现

```python
def levelset_evolution(phi, f, g, lambda_param, mu, dt, max_iter):
    """
    水平集演化
    
    参数:
        phi: 初始SDF
        f: 区域力
        g: 边缘指示器
        lambda_param: 区域项权重
        mu: SDF约束权重
        dt: 时间步长
    """
    for iter in range(max_iter):
        phi_old = phi.copy()
        
        # 计算梯度
        grad_phi_x, grad_phi_y = gradient(phi)
        grad_phi_mag = np.sqrt(grad_phi_x**2 + grad_phi_y**2 + 1e-10)
        
        # 曲率
        curvature = divergence(grad_phi_x / grad_phi_mag, 
                               grad_phi_y / grad_phi_mag)
        
        # 边缘力
        edge_force = curvature * g + dot(gradient(g), 
                                          (grad_phi_x, grad_phi_y)) / grad_phi_mag
        
        # 区域力
        region_force = lambda_param * f
        
        # SDF约束项 (保持 |∇φ| ≈ 1)
        sdf_constraint = mu * (laplacian(phi) - curvature)
        
        # 更新
        delta_phi = delta_function(phi)
        phi = phi + dt * delta_phi * (edge_force + region_force) + dt * sdf_constraint
        
        # 重新初始化（每几步）
        if iter % 5 == 0:
            phi = reinitialize_sdf(phi)
        
        # 检查收敛
        if np.max(np.abs(phi - phi_old)) < 1e-5:
            break
    
    return phi

def delta_function(phi, epsilon=1.0):
    """平滑的Dirac delta函数"""
    return epsilon / (np.pi * (phi**2 + epsilon**2))

def reinitialize_sdf(phi, max_iter=20):
    """
    重新初始化SDF（保持 |∇φ| = 1）
    
    使用快速行进法或PDE方法
    """
    # 简单实现：符号函数 + 距离变换
    sign_phi = np.sign(phi)
    
    # 从0水平集计算距离
    from scipy.ndimage import distance_transform_edt
    dist_outside = distance_transform_edt(phi > 0)
    dist_inside = distance_transform_edt(phi <= 0)
    
    phi_new = dist_inside - dist_outside
    
    return phi_new
```

### 4.3 多类水平集

**耦合水平集**：
- 避免重叠和空洞
- 使用耦合约束

```python
def multiphase_levelset(f, K, max_iter):
    """
    多相水平集分割
    
    参数:
        f: 图像
        K: 相数
    """
    # 初始化K个SDF
    phi = [initialize_sdf(f.shape) for _ in range(K)]
    
    for iter in range(max_iter):
        for k in range(K):
            # 计算其他相的约束
            other_constraint = compute_other_phases_constraint(phi, k)
            
            # 演化第k个水平集
            phi[k] = levelset_evolution(phi[k], f_k, g, 
                                        lambda_param, mu, dt, 1)
            
            # 处理重叠
            phi = resolve_overlap(phi)
    
    return phi
```

---

## 五、与井盖检测的联系

### 5.1 井盖的几何特性

**圆形特征**：
- 完美的圆形边界
- 平滑的曲率
- 拓扑简单

**SDF的优势**：
- 圆形对应特定的SDF形式
- 可直接计算圆心和半径
- 保持圆形拓扑

### 5.2 圆形SDF

**圆的SDF**：
对于圆心 $c$，半径 $r$：
$$\phi_c(x) = |x - c| - r$$

**验证**：
- 在圆上：$|x - c| = r$ → $\phi = 0$ ✓
- 在圆内：$|x - c| < r$ → $\phi < 0$ ✓
- 在圆外：$|x - c| > r$ → $\phi > 0$ ✓

### 5.3 改进的圆形检测

```python
def circular_levelset_detection(image, num_circles=1):
    """
    基于水平集的圆形检测
    """
    # 初始化圆形SDF
    centers = initialize_centers(image)
    radii = [20] * num_circles
    
    phi = [create_circular_sdf(image.shape, c, r) 
           for c, r in zip(centers, radii)]
    
    # 水平集演化
    for iter in range(max_iter):
        for i in range(num_circles):
            # 边缘力吸引
            phi[i] = evolve_with_edge_attraction(phi[i], image)
            
            # 圆形约束（保持圆形）
            phi[i] = enforce_circular_shape(phi[i])
        
        # 处理重叠
        if num_circles > 1:
            phi = handle_overlap(phi)
    
    # 提取圆参数
    circles = []
    for i in range(num_circles):
        center, radius = extract_circle_from_sdf(phi[i])
        circles.append((center, radius))
    
    return circles

def enforce_circular_shape(phi):
    """
    强制SDF保持圆形
    
    方法：拟合最佳圆，然后向圆形SDF投影
    """
    # 提取当前0水平集
    boundary = extract_boundary(phi == 0)
    
    # 拟合圆
    center, radius = fit_circle(boundary)
    
    # 重建圆形SDF
    phi_circular = create_circular_sdf(phi.shape, center, radius)
    
    # 插值混合（保持演化连续性）
    alpha = 0.1
    return (1-alpha) * phi + alpha * phi_circular
```

---

## 六、总结

### 6.1 核心贡献

1. **SDF表示**：隐式表示边界，便于几何操作
2. **曲率约束**：直接控制边界平滑度
3. **拓扑保持**：水平集方法保持连通性

### 6.2 与系列论文的关系

```
[2-01] TV分割: 像素级方法
本文[2-15]: 几何级方法（SDF）
[2-20] 深度学习: 数据驱动方法
```

### 6.3 应用价值

- 需要精确几何的应用
- 圆形/椭圆形目标检测
- 拓扑约束重要的场景

---

## 七、自测题

### 基础题

1. **证明**：SDF满足 $|\nabla \phi| = 1$（在边界附近）。

2. **实现**：完成 `create_circular_sdf` 函数。

3. **分析**：SDF约束项 $(|\nabla \phi| - 1)^2$ 的作用是什么？

### 进阶题

4. **设计**：设计基于水平集的同心圆检测算法。

5. **讨论**：对比SDF方法与TV方法的优缺点。

---

**本精读笔记完成日期**：2026年2月  
**字数**：约9,000字
