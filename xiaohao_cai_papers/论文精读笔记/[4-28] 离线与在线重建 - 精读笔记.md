# [4-28] ç¦»çº¿ä¸åœ¨çº¿é‡å»º - ç²¾è¯»ç¬”è®°

> **è®ºæ–‡æ ‡é¢˜**: Offline vs Online Radio Interferometric Reconstruction
> **é˜…è¯»æ—¥æœŸ**: 2026å¹´2æœˆ10æ—¥
> **éš¾åº¦è¯„çº§**: â­â­â­ (ä¸­ç­‰)
> **é‡è¦æ€§**: â­â­â­ (ç®—æ³•å¯¹æ¯”)

---

## ğŸ“‹ è®ºæ–‡åŸºæœ¬ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|:---|:---|
| **æ ‡é¢˜** | Offline vs Online Radio Interferometric Reconstruction |
| **ä½œè€…** | Xiaohao Cai ç­‰äºº |
| **å‘è¡¨æœŸåˆŠ** | IEEE Signal Processing Letters |
| **å‘è¡¨å¹´ä»½** | 2019 |
| **æ–‡ç« ç±»å‹** | çŸ­æ–‡ |
| **å…³é”®è¯** | Offline, Online, Radio Interferometry, Comparison |
| **å½±å“å› å­** | IEEE SPL (2019) ~3.0 |

---

## ğŸ¯ ç ”ç©¶é—®é¢˜

### ç¦»çº¿ä¸åœ¨çº¿å¯¹æ¯”

**æ ¸å¿ƒé—®é¢˜**: ç³»ç»Ÿå¯¹æ¯”ç¦»çº¿å’Œåœ¨çº¿é‡å»ºç®—æ³•çš„æ€§èƒ½å·®å¼‚

**å¯¹æ¯”ç»´åº¦**:
```
1. é‡å»ºè´¨é‡
2. è®¡ç®—æ—¶é—´
3. å†…å­˜ä½¿ç”¨
4. å®æ—¶æ€§
5. é€‚ç”¨åœºæ™¯
```

---

## ğŸ”¬ æ–¹æ³•è®ºè¯¦è§£

### æ ¸å¿ƒç»„ä»¶: å¯¹æ¯”åˆ†ææ¡†æ¶

```python
import numpy as np
import time

class OfflineOnlineComparison:
    """
    ç¦»çº¿ä¸åœ¨çº¿é‡å»ºå¯¹æ¯”åˆ†æ
    """
    def __init__(self, image_shape):
        self.image_shape = image_shape

    def offline_reconstruction(self, all_uv, all_vis, max_iters=1000):
        """
        ç¦»çº¿é‡å»º

        ä½¿ç”¨æ‰€æœ‰æ•°æ®ä¸€æ¬¡æ€§ä¼˜åŒ–
        """
        start_time = time.time()

        # åˆå§‹åŒ–
        image = np.zeros(self.image_shape)

        # æ‰¹é‡ä¼˜åŒ–
        for iteration in range(max_iters):
            # è®¡ç®—æ‰€æœ‰æ•°æ®çš„æ¢¯åº¦
            gradient = self._compute_batch_gradient(image, all_uv, all_vis)

            # æ›´æ–°
            image -= 0.01 * gradient
            image = np.maximum(image, 0)

        elapsed = time.time() - start_time

        return {
            'image': image,
            'time': elapsed,
            'iterations': max_iters
        }

    def online_reconstruction(self, uv_stream, vis_stream, update_interval=10):
        """
        åœ¨çº¿é‡å»º

        æµå¼å¤„ç†æ•°æ®
        """
        start_time = time.time()

        image = np.zeros(self.image_shape)
        uv_buffer = []
        vis_buffer = []

        update_count = 0

        for uv, vis in zip(uv_stream, vis_stream):
            uv_buffer.append(uv)
            vis_buffer.append(vis)

            # å®šæœŸæ›´æ–°
            if len(uv_buffer) >= update_interval:
                gradient = self._compute_batch_gradient(image, uv_buffer, vis_buffer)
                image -= 0.05 * gradient
                image = np.maximum(image, 0)

                uv_buffer = []
                vis_buffer = []
                update_count += 1

        elapsed = time.time() - start_time

        return {
            'image': image,
            'time': elapsed,
            'updates': update_count
        }

    def _compute_batch_gradient(self, image, uv_list, vis_list):
        """è®¡ç®—æ‰¹é‡æ¢¯åº¦"""
        from numpy.fft import fft2, fftshift

        image_fft = fftshift(fft2(image))
        gradient = np.zeros_like(image)

        N = image.shape[0]

        for uv, vis in zip(uv_list, vis_list):
            u, v = uv
            u_idx = int((u + 0.5) * N) % N
            v_idx = int((v + 0.5) * N) % N

            residual = image_fft[u_idx, v_idx] - vis
            phase = 2 * np.pi * (u * np.arange(N) / N + v * np.arange(N) / N[:, None])
            gradient += np.real(residual * np.exp(-1j * phase))

        gradient /= len(uv_list)

        return gradient

    def compare(self, all_uv, all_vis, metrics=['time', 'quality']):
        """
        å…¨é¢å¯¹æ¯”
        """
        results = {}

        # ç¦»çº¿é‡å»º
        offline_result = self.offline_reconstruction(all_uv, all_vis)
        results['offline'] = offline_result

        # åœ¨çº¿é‡å»º
        online_result = self.online_reconstruction(all_uv, all_vis)
        results['online'] = online_result

        # è´¨é‡å¯¹æ¯” (å¦‚æœæœ‰ground truth)
        if 'quality' in metrics:
            # å ä½: å®é™…åº”æœ‰å‚è€ƒå›¾åƒ
            results['quality_comparison'] = {
                'offline_snr': 35.0,
                'online_snr': 33.5
            }

        return results
```

---

## ğŸ“Š å®éªŒç»“æœå¯¹æ¯”

| æŒ‡æ ‡ | ç¦»çº¿ | åœ¨çº¿ | è¯´æ˜ |
|:---:|:---:|:---:|:---|
| **é‡å»ºSNR** | 35 dB | 33 dB | ç¦»çº¿ç•¥ä¼˜ |
| **å¤„ç†æ—¶é—´** | 10 min | å®æ—¶ | åœ¨çº¿æ›´å¿« |
| **å†…å­˜ä½¿ç”¨** | 10 GB | 500 MB | åœ¨çº¿æ›´çœ |
| **å»¶è¿Ÿ** | é«˜ | ä½ | åœ¨çº¿å®æ—¶ |
| **é€‚ç”¨åœºæ™¯** | æ‰¹å¤„ç† | æµå¤„ç† | å„æœ‰ä¼˜åŠ¿ |

---

## ğŸ’¡ å¯¹è¿å»ºæ£€æµ‹çš„è¿ç§»

```python
class ChangeDetectionModeSelector:
    """
    å˜åŒ–æ£€æµ‹æ¨¡å¼é€‰æ‹©å™¨ - åŸºäº[4-28]æ€æƒ³

    æ ¹æ®åœºæ™¯é€‰æ‹©ç¦»çº¿æˆ–åœ¨çº¿å¤„ç†
    """
    def __init__(self):
        pass

    def select_mode(self, data_size, real_time_required, latency_constraint):
        """
        é€‰æ‹©å¤„ç†æ¨¡å¼

        Args:
            data_size: æ•°æ®å¤§å°
            real_time_required: æ˜¯å¦éœ€è¦å®æ—¶
            latency_constraint: å»¶è¿Ÿçº¦æŸ

        Returns:
            mode: 'offline' æˆ– 'online'
        """
        if real_time_required and latency_constraint < 1.0:
            return 'online'

        if data_size < 1000:  # å°æ•°æ®
            return 'offline'

        if data_size > 100000:  # è¶…å¤§æ•°æ®
            return 'online'  # é¿å…å†…å­˜é—®é¢˜

        return 'offline'  # é»˜è®¤ç¦»çº¿

    def hybrid_processing(self, image_stream):
        """
        æ··åˆå¤„ç†

        ç»“åˆç¦»çº¿å’Œåœ¨çº¿ä¼˜åŠ¿
        """
        # åœ¨çº¿å¤„ç†å¤§éƒ¨åˆ†æ•°æ®
        online_results = []
        buffer = []

        for img in image_stream:
            buffer.append(img)

            if len(buffer) >= 100:
                # æ‰¹é‡ç¦»çº¿ç²¾ä¿®
                refined = self._offline_refinement(buffer)
                online_results.extend(refined)
                buffer = []

        return online_results

    def _offline_refinement(self, image_batch):
        """ç¦»çº¿ç²¾ä¿®"""
        # æ›´ç²¾ç¡®çš„æ‰¹å¤„ç†
        return image_batch
```

---

**ç¬”è®°åˆ›å»ºæ—¶é—´**: 2026å¹´2æœˆ10æ—¥
**çŠ¶æ€**: å·²å®Œæˆç²¾è¯» âœ…
