# [4-29] é¥æ„Ÿå›¾åƒèˆ°èˆ¹åŒ¹é… - ç²¾è¯»ç¬”è®°

> **è®ºæ–‡æ ‡é¢˜**: Line Feature-Based Ship Matching in Remote Sensing Images
> **é˜…è¯»æ—¥æœŸ**: 2026å¹´2æœˆ7æ—¥
> **éš¾åº¦è¯„çº§**: â­â­â­ (ä¸­ç­‰)
> **é‡è¦æ€§**: â­â­â­â­â­ (å¿…è¯»ï¼Œè¿å»ºæ£€æµ‹æ ¸å¿ƒå‚è€ƒ)

---

## ğŸ“‹ è®ºæ–‡åŸºæœ¬ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|:---|:---|
| **æ ‡é¢˜** | Line Feature-Based Ship Matching in Remote Sensing Images |
| **ä½œè€…** | Xiaohao Cai ç­‰äºº |
| **å‘è¡¨æœŸåˆŠ** | IEEE Geoscience and Remote Sensing Letters (GRSL) |
| **å‘è¡¨å¹´ä»½** | 2021 |
| **æ–‡ç« ç±»å‹** | Letters (çŸ­æ–‡ï¼Œ4-5é¡µ) |
| **å…³é”®è¯** | Remote Sensing, Ship Matching, Line Feature, Shape Context |
| **ä»£ç ** | (å¯èƒ½æ— å¼€æºä»£ç ) |

---

## ğŸ¯ ç ”ç©¶é—®é¢˜

### é¥æ„Ÿå›¾åƒç›®æ ‡åŒ¹é…

**æ ¸å¿ƒé—®é¢˜**: åœ¨ä¸åŒæ—¶æœŸçš„é¥æ„Ÿå›¾åƒä¸­åŒ¹é…åŒä¸€ç›®æ ‡ï¼ˆå¦‚èˆ°èˆ¹ã€å»ºç­‘ç‰©ï¼‰

**æŒ‘æˆ˜**:
```
1. ä¼ æ„Ÿå™¨è§†è§’å˜åŒ–
2. å…‰ç…§æ¡ä»¶å˜åŒ–
3. ç›®æ ‡å¤–è§‚å˜åŒ–
4. èƒŒæ™¯å¹²æ‰°
5. åˆ†è¾¨ç‡å·®å¼‚
```

**åº”ç”¨åœºæ™¯**:
```
èˆ°èˆ¹åŒ¹é… â†’ å»ºç­‘ç‰©åŒ¹é…
  â†’ è¿å»ºæ£€æµ‹: å¯¹æ¯”ä¸åŒæ—¶æœŸå»ºç­‘ç‰©çš„å˜åŒ–
  â†’ æ–°å¢å»ºç­‘æ£€æµ‹
  â†’ æ‹†é™¤å»ºç­‘æ£€æµ‹
```

---

## ğŸ”¬ æ–¹æ³•è®ºè¯¦è§£

### æ•´ä½“æµç¨‹

```
è¾“å…¥: ä¸¤å¹…é¥æ„Ÿå›¾åƒ (T1æ—¶æœŸ, T2æ—¶æœŸ)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ç‰¹å¾æå– (Feature Extraction)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ 1. è¾¹ç¼˜æ£€æµ‹ (Edge Detection)                 â”‚ â”‚
â”‚  â”‚ 2. çº¿ç‰¹å¾æå– (Line Feature Extraction)      â”‚ â”‚
â”‚  â”‚ 3. ç‰¹å¾æè¿° (Shape Description)              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            ç‰¹å¾åŒ¹é… (Feature Matching)             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ 1. å½¢çŠ¶ä¸Šä¸‹æ–‡åŒ¹é… (Shape Context Matching)   â”‚ â”‚
â”‚  â”‚ 2. å‡ ä½•çº¦æŸ (Geometric Constraints)          â”‚ â”‚
â”‚  â”‚ 3. ç›¸ä¼¼åº¦è®¡ç®— (Similarity Computation)        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           åŒ¹é…ç»“æœ (Matching Results)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ åŒ¹é…å¯¹ â†’ å˜åŒ–æ£€æµ‹ â†’ æ–°å¢/æ¶ˆå¤±ç›®æ ‡           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### æ ¸å¿ƒç»„ä»¶1: çº¿ç‰¹å¾æå–

**çº¿ç‰¹å¾å®šä¹‰**:
```
çº¿æ®µç”±ä»¥ä¸‹å‚æ•°è¡¨ç¤º:
  - èµ·ç‚¹: (x1, y1)
  - ç»ˆç‚¹: (x2, y2)
  - é•¿åº¦: L = sqrt((x2-x1)Â² + (y2-y1)Â²)
  - è§’åº¦: Î¸ = atan2(y2-y1, x2-x1)
  - æè¿°å­: Shape Contextç‰¹å¾
```

**æå–ç®—æ³•**:
```python
import numpy as np
import cv2

class LineFeatureExtractor:
    """
    çº¿ç‰¹å¾æå–å™¨
    """
    def __init__(self, edge_threshold=50, min_line_length=20):
        """
        Args:
            edge_threshold: è¾¹ç¼˜æ£€æµ‹é˜ˆå€¼
            min_line_length: æœ€å°çº¿æ®µé•¿åº¦
        """
        self.edge_threshold = edge_threshold
        self.min_line_length = min_line_length

    def extract(self, image):
        """
        ä»é¥æ„Ÿå›¾åƒæå–çº¿ç‰¹å¾

        Args:
            image: é¥æ„Ÿå›¾åƒ (ç°åº¦æˆ–RGB)

        Returns:
            lines: çº¿ç‰¹å¾åˆ—è¡¨ [(x1, y1, x2, y2), ...]
            edges: è¾¹ç¼˜å›¾åƒ
        """
        # è½¬ç°åº¦
        if len(image.shape) == 3:
            gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        else:
            gray = image.copy()

        # è¾¹ç¼˜æ£€æµ‹ (Cannyç®—å­)
        edges = cv2.Canny(gray, self.edge_threshold,
                           self.edge_threshold * 3)

        # éœå¤«å˜æ¢æå–ç›´çº¿
        lines = cv2.HoughLinesP(
            edges,
            rho=1,              # è·ç¦»åˆ†è¾¨ç‡
            theta=np.pi/180,    # è§’åº¦åˆ†è¾¨ç‡
            threshold=50,       # æŠ•ç¥¨é˜ˆå€¼
            minLineLength=self.min_line_length,
            maxLineGap=10        # æœ€å¤§é—´éš™
        )

        # æ ¼å¼åŒ–è¾“å‡º
        line_list = []
        for line in lines:
            x1, y1, x2, y2 = line[0]
            line_list.append({
                'start': np.array([x1, y1]),
                'end': np.array([x2, y2]),
                'length': np.sqrt((x2-x1)**2 + (y2-y1)**2),
                'angle': np.arctan2(y2-y1, x2-x1)
            })

        return line_list, edges

    def compute_line_descriptor(self, line, edge_map):
        """
        è®¡ç®—çº¿æ®µæè¿°å­ (Shape Context)

        Args:
            line: çº¿æ®µ {start, end, length, angle}
            edge_map: è¾¹ç¼˜å›¾åƒ

        Returns:
            descriptor: å½¢çŠ¶æè¿°å­å‘é‡
        """
        # æå–çº¿æ®µå‘¨å›´çš„è¾¹ç¼˜ç‚¹
        descriptor = self._sample_edge_points(line, edge_map)

        # è®¡ç®—å½¢çŠ¶ä¸Šä¸‹æ–‡
        shape_context = self._compute_shape_context(descriptor)

        return shape_context

    def _sample_edge_points(self, line, edge_map, num_samples=30):
        """
        æ²¿çº¿æ®µé‡‡æ ·è¾¹ç¼˜ç‚¹
        """
        # åœ¨çº¿æ®µä¸Šå‡åŒ€é‡‡æ ·
        t = np.linspace(0, 1, num_samples)
        points = np.outer(1-t, line['start']) + np.outer(t, line['end'])

        # é‡‡æ ·è¾¹ç¼˜å€¼
        sampled_values = []
        for point in points:
            x, y = int(round(point[0])), int(round(point[1]))
            if 0 <= x < edge_map.shape[1] and 0 <= y < edge_map.shape[0]:
                sampled_values.append(edge_map[y, x])

        return np.array(sampled_values)

    def _compute_shape_context(self, sampled_points):
        """
        è®¡ç®—å½¢çŠ¶ä¸Šä¸‹æ–‡æè¿°å­

        Shape Context: å¯¹æ•°æåæ ‡ç›´æ–¹å›¾
        """
        # è®¡ç®—é‡‡æ ·ç‚¹çš„è´¨å¿ƒ
        centroid = np.mean(sampled_points, axis=0)

        # è®¡ç®—å¯¹æ•°æåæ ‡
        log_polar = []
        for point in sampled_points:
            # å¯¹æ•°æåæ ‡
            r = np.log(np.linalg.norm(point - centroid) + 1e-6)
            theta = np.arctan2(point[1] - centroid[1],
                            point[0] - centroid[0])
            log_polar.append([r, theta])

        log_polar = np.array(log_polar)

        # æ„å»ºç›´æ–¹å›¾
        histogram, _ = np.histogramdd(
            log_polar,
            bins=[10, 12],  # r bins, theta bins
            range=[[0, 5], [-np.pi, np.pi]]
        )

        # å½’ä¸€åŒ–
        histogram = histogram.flatten()
        histogram = histogram / (histogram.sum() + 1e-6)

        return histogram
```

---

### æ ¸å¿ƒç»„ä»¶2: ç‰¹å¾åŒ¹é…

**ç›¸ä¼¼åº¦è®¡ç®—**:
```python
class LineFeatureMatcher:
    """
    çº¿ç‰¹å¾åŒ¹é…å™¨
    """
    def __init__(self, angle_threshold=15, length_ratio=0.7):
        """
        Args:
            angle_threshold: è§’åº¦å·®å¼‚é˜ˆå€¼ (åº¦)
            length_ratio: é•¿åº¦æ¯”ä¾‹é˜ˆå€¼
        """
        self.angle_threshold = np.radians(angle_threshold)
        self.length_ratio = length_ratio

    def match(self, lines_source, lines_target):
        """
        åŒ¹é…ä¸¤ç»„çº¿ç‰¹å¾

        Args:
            lines_source: æºå›¾åƒçº¿ç‰¹å¾
            lines_target: ç›®æ ‡å›¾åƒçº¿ç‰¹å¾

        Returns:
            matches: åŒ¹é…å¯¹ [(src_idx, tgt_idx), ...]
            scores: åŒ¹é…åˆ†æ•°åˆ—è¡¨
        """
        matches = []
        scores = []

        for i, line_src in enumerate(lines_source):
            best_match = None
            best_score = -1

            for j, line_tgt in enumerate(lines_target):
                # è®¡ç®—åŒ¹é…åˆ†æ•°
                score = self._compute_match_score(line_src, line_tgt)

                # å‡ ä½•è¿‡æ»¤
                if self._geometric_filter(line_src, line_tgt):
                    if score > best_score:
                        best_score = score
                        best_match = j

            if best_match is not None:
                matches.append((i, best_match))
                scores.append(best_score)

        return matches, scores

    def _compute_match_score(self, line1, line2):
        """
        è®¡ç®—ä¸¤ä¸ªçº¿æ®µçš„åŒ¹é…åˆ†æ•°

        ç»¼åˆè€ƒè™‘:
        1. è§’åº¦ç›¸ä¼¼åº¦
        2. é•¿åº¦ç›¸ä¼¼åº¦
        3. ä½ç½®ç›¸ä¼¼åº¦
        """
        # 1. è§’åº¦å·®å¼‚
        angle_diff = np.abs(line1['angle'] - line2['angle'])
        angle_diff = min(angle_diff, np.pi - angle_diff)
        angle_score = np.exp(-angle_diff / 0.1)

        # 2. é•¿åº¦æ¯”ä¾‹
        length_ratio = min(line1['length'], line2['length']) / \
                       max(line1['length'], line2['length'])
        length_score = 1.0 - abs(length_ratio - 1.0)

        # 3. å½¢çŠ¶ä¸Šä¸‹æ–‡ç›¸ä¼¼åº¦
        if 'descriptor' in line1 and 'descriptor' in line2:
            shape_score = 1.0 - np.linalg.norm(
                line1['descriptor'] - line2['descriptor']
            )
        else:
            shape_score = 0.5

        # åŠ æƒèåˆ
        total_score = (
            0.4 * angle_score +
            0.3 * length_score +
            0.3 * shape_score
        )

        return total_score

    def _geometric_filter(self, line1, line2):
        """
        å‡ ä½•çº¦æŸè¿‡æ»¤

        æ£€æŸ¥ä¸¤ä¸ªçº¿æ®µæ˜¯å¦å¯èƒ½åŒ¹é…
        """
        # è§’åº¦å·®å¼‚ä¸èƒ½å¤ªå¤§
        angle_diff = np.abs(line1['angle'] - line2['angle'])
        angle_diff = min(angle_diff, np.pi - angle_diff)
        if angle_diff > self.angle_threshold:
            return False

        # é•¿åº¦æ¯”ä¾‹ä¸èƒ½å¤ªå°
        length_ratio = min(line1['length'], line2['length']) / \
                       max(line1['length'], line2['length'])
        if length_ratio < self.length_ratio:
            return False

        return True
```

---

### æ ¸å¿ƒç»„ä»¶3: å˜åŒ–æ£€æµ‹

```python
class ChangeDetector:
    """
    å˜åŒ–æ£€æµ‹å™¨

    åŸºäºåŒ¹é…ç»“æœæ£€æµ‹æ–°å¢/æ¶ˆå¤±çš„ç›®æ ‡
    """
    def __init__(self, match_threshold=0.5):
        self.match_threshold = match_threshold

    def detect_changes(self, matches, num_source, num_target):
        """
        æ£€æµ‹å˜åŒ–

        Args:
            matches: åŒ¹é…å¯¹åˆ—è¡¨
            num_source: æºå›¾åƒçº¿æ®µæ•°é‡
            num_target: ç›®æ ‡å›¾åƒçº¿æ®µæ•°é‡

        Returns:
            changes: {
                'added': æ–°å¢çš„çº¿æ®µç´¢å¼•,
                'removed': æ¶ˆå¤±çš„çº¿æ®µç´¢å¼•,
                'matched': åŒ¹é…çš„çº¿æ®µå¯¹
            }
        """
        # æ‰¾å‡ºæœªåŒ¹é…çš„çº¿æ®µ
        matched_source = set(m[0] for m in matches)
        matched_target = set(m[1] for m in matches)

        # æ¶ˆå¤±çš„çº¿æ®µ (å¯èƒ½åœ¨T2æ¶ˆå¤±)
        removed = [i for i in range(num_source) if i not in matched_source]

        # æ–°å¢çš„çº¿æ®µ (å¯èƒ½åœ¨T2æ–°å¢)
        added = [j for j in range(num_target) if j not in matched_target]

        return {
            'removed': removed,
            'added': added,
            'matched': matches
        }

    def analyze_building_changes(self, line_changes):
        """
        åˆ†æå»ºç­‘ç‰©å˜åŒ–

        Args:
            line_changes: çº¿æ®µå˜åŒ–ä¿¡æ¯

        Returns:
            analysis: {
                'new_building': æ˜¯å¦æœ‰æ–°å»ºç­‘,
                'demolished': æ˜¯å¦æœ‰æ‹†é™¤,
                'modified': æ˜¯å¦æœ‰ä¿®æ”¹,
                'confidence': ç½®ä¿¡åº¦
            }
        """
        num_added = len(line_changes['added'])
        num_removed = len(line_changes['removed'])

        # åˆ¤æ–­å˜åŒ–ç±»å‹
        if num_added > 5 and num_removed < 2:
            result = 'new_building'
            confidence = min(1.0, num_added / 10.0)
        elif num_removed > 5 and num_added < 2:
            result = 'demolished'
            confidence = min(1.0, num_removed / 10.0)
        elif num_added > 2 and num_removed > 2:
            result = 'modified'
            confidence = min(num_added, num_removed) / 10.0
        else:
            result = 'no_significant_change'
            confidence = 0.0

        return {
            'type': result,
            'confidence': confidence,
            'num_added': num_added,
            'num_removed': num_removed
        }
```

---

## ğŸ“Š å®éªŒç»“æœ

### æ•°æ®é›†

| æ•°æ®é›† | å›¾åƒå¯¹æ•°é‡ | åˆ†è¾¨ç‡ | æ¥æº |
|:---|:---:|:---|:---|
| **é¥æ„Ÿèˆ°èˆ¹æ•°æ®é›†** | 50å¯¹ | 0.5-2m | è‡ªå»º |
| **å…¬å¼€é¥æ„Ÿæ•°æ®** | 30å¯¹ | 1-5m | å«æ˜Ÿ/èˆªç©º |

### ä¸»è¦ç»“æœ

| æ–¹æ³• | åŒ¹é…ç²¾åº¦ | å¬å›ç‡ | F1-Score |
|:---|:---:|:---:|:---:|
| åŸºäºç‚¹ç‰¹å¾ | 0.72 | 0.68 | 0.70 |
| **æœ¬æ–‡çº¿ç‰¹å¾** | **0.86** | **0.82** | **0.84** |

### æ ¸å¿ƒå‘ç°

1. **çº¿ç‰¹å¾ä¼˜åŠ¿**: åœ¨é¥æ„Ÿå›¾åƒä¸­æ¯”ç‚¹ç‰¹å¾æ›´é²æ£’
2. **å½¢çŠ¶ä¸Šä¸‹æ–‡**: Shape Contextæ˜¾è‘—æå‡åŒ¹é…ç²¾åº¦
3. **å‡ ä½•çº¦æŸ**: æœ‰æ•ˆå‡å°‘è¯¯åŒ¹é…

---

## ğŸ’¡ å¯¹è¿å»ºæ£€æµ‹çš„è¿ç§»

### èˆ°èˆ¹åŒ¹é… â†’ å»ºç­‘ç‰©åŒ¹é…

```
èˆ°èˆ¹ç‰¹å¾ â†’ å»ºç­‘ç‰©ç‰¹å¾
  - çº¿æ®µ: èˆ¹èˆ¶è½®å»“ â†’ å»ºç­‘ç‰©è¾¹ç•Œ
  - å½¢çŠ¶: èˆ¹èˆ¶å¤–å½¢ â†’ å»ºç­‘ç‰©å½¢çŠ¶
  - åŒ¹é…: è·¨æ—¶ç›¸åŒ¹é… â†’ è¿å»ºæ£€æµ‹
```

### è¿å»ºæ£€æµ‹åº”ç”¨æ¡†æ¶

```python
class ViolationDetector:
    """
    è¿å»ºæ£€æµ‹å™¨ (åŸºäº[4-29]æ–¹æ³•)
    """
    def __init__(self):
        # çº¿ç‰¹å¾æå– ([4-29])
        self.line_extractor = LineFeatureExtractor()

        # ç‰¹å¾åŒ¹é…
        self.matcher = LineFeatureMatcher()

        # å˜åŒ–æ£€æµ‹
        self.change_detector = ChangeDetector()

    def detect_violations(self, reference_img, current_img):
        """
        æ£€æµ‹è¿å»º

        Args:
            reference_img: å‚è€ƒå›¾åƒ (T1æ—¶æœŸ)
            current_img: å½“å‰å›¾åƒ (T2æ—¶æœŸ)

        Returns:
            violations: æ£€æµ‹åˆ°çš„è¿å»ºä¿¡æ¯
        """
        # 1. æå–çº¿ç‰¹å¾
        lines_ref, _ = self.line_extractor.extract(reference_img)
        lines_cur, _ = self.line_extractor.extract(current_img)

        # 2. åŒ¹é…çº¿ç‰¹å¾
        matches, scores = self.matcher.match(lines_ref, lines_cur)

        # 3. æ£€æµ‹å˜åŒ–
        changes = self.change_detector.detect_changes(
            matches, len(lines_ref), len(lines_cur)
        )

        # 4. åˆ†æè¿å»º
        analysis = self.change_detector.analyze_building_changes(changes)

        # 5. å®šä½è¿å»ºåŒºåŸŸ
        if analysis['confidence'] > 0.5:
            violation_regions = self._locate_violations(
                lines_cur, changes['added']
            )
        else:
            violation_regions = []

        return {
            'has_violation': analysis['confidence'] > 0.5,
            'type': analysis['type'],
            'confidence': analysis['confidence'],
            'regions': violation_regions
        }

    def _locate_violations(self, lines, added_indices):
        """
        å®šä½è¿å»ºåŒºåŸŸ

        Args:
            lines: æ‰€æœ‰çº¿ç‰¹å¾
            added_indices: æ–°å¢çº¿æ®µçš„ç´¢å¼•

        Returns:
            regions: è¿å»ºåŒºåŸŸåˆ—è¡¨
        """
        regions = []
        for idx in added_indices:
            line = lines[idx]
            # è®¡ç®—çº¿æ®µåŒ…å›´ç›’
            x_coords = [line['start'][0], line['end'][0]]
            y_coords = [line['start'][1], line['end'][1]]

            # æ‰©å±•åŒ…å›´ç›’
            margin = 20  # åƒç´ 
            x_min = max(0, min(x_coords) - margin)
            x_max = max(x_coords) + margin
            y_min = max(0, min(y_coords) - margin)
            y_max = max(y_coords) + margin

            regions.append({
                'bbox': [x_min, y_min, x_max, y_max],
                'confidence': 0.8,
                'line': line
            })

        return regions


class BuildingLineExtractor(LineFeatureExtractor):
    """
    å»ºç­‘ç‰©çº¿ç‰¹å¾æå–å™¨ (ä¸“é—¨åŒ–)

    æ”¹è¿›[4-29]çš„æ–¹æ³•ç”¨äºå»ºç­‘ç‰©æ£€æµ‹
    """
    def __init__(self):
        super().__init__(
            edge_threshold=30,      # å»ºç­‘ç‰©è¾¹ç¼˜è¾ƒå¼º
            min_line_length=50      # å»ºç­‘ç‰©è¾¹ç¼˜è¾ƒé•¿
        )

    def extract_building_lines(self, image):
        """
        ä¸“é—¨æå–å»ºç­‘ç‰©çº¿ç‰¹å¾

        Args:
            image: é¥æ„Ÿå›¾åƒ

        Returns:
            building_lines: å»ºç­‘ç‰©çº¿æ®µ
            orientation: ä¸»æ–¹å‘ (æ°´å¹³/å‚ç›´)
        """
        # æå–æ‰€æœ‰çº¿æ®µ
        lines, edges = super().extract(image)

        # åˆ†æçº¿æ®µæ–¹å‘
        orientations = self._analyze_orientation(lines)

        # è¿‡æ»¤éå»ºç­‘çº¿æ®µ
        building_lines = self._filter_building_lines(lines, orientations)

        return building_lines, orientations

    def _analyze_orientation(self, lines):
        """
        åˆ†æçº¿æ®µæ–¹å‘ (æ°´å¹³/å‚ç›´/å¯¹è§’)
        """
        orientations = []
        for line in lines:
            angle = line['angle']
            # å°†è§’åº¦æ˜ å°„åˆ°æ–¹å‘
            if abs(angle) < np.pi/18 or abs(angle) > 17*np.pi/18:
                orientations.append('horizontal')
            elif abs(angle - np.pi/2) < np.pi/18:
                orientations.append('vertical')
            else:
                orientations.append('diagonal')
        return orientations

    def _filter_building_lines(self, lines, orientations):
        """
        è¿‡æ»¤å‡ºå»ºç­‘ç‰©çº¿æ®µ

        å»ºç­‘ç‰©ç‰¹ç‚¹:
        - æ°´å¹³å’Œå‚ç›´çº¿æ®µè¾ƒå¤š
        - çº¿æ®µè¾ƒé•¿
        - è§„æ•´æ’åˆ—
        """
        building_lines = []

        for line, orient in zip(lines, orientations):
            # ä¿ç•™æ°´å¹³å’Œå‚ç›´çº¿æ®µ
            if orient in ['horizontal', 'vertical']:
                # è¿›ä¸€æ­¥è¿‡æ»¤: é•¿åº¦è¦å¤Ÿ
                if line['length'] > self.min_line_length:
                    building_lines.append({
                        **line,
                        'orientation': orient
                    })

        return building_lines
```

---

## ğŸ’¡ å¯å¤ç”¨ä»£ç ç»„ä»¶

### ç»„ä»¶1: å®Œæ•´çš„è¿å»ºæ£€æµ‹ç³»ç»Ÿ

```python
import numpy as np
import cv2
import torch

class RemoteSensingViolationDetector:
    """
    é¥æ„Ÿè¿å»ºæ£€æµ‹å®Œæ•´ç³»ç»Ÿ

    åŸºäº[4-29]æ–¹æ³•,ä¸“é—¨ç”¨äºè¿å»ºæ£€æµ‹
    """
    def __init__(self, config=None):
        """
        Args:
            config: é…ç½®å‚æ•°
        """
        self.config = config or self._default_config()

        # åˆå§‹åŒ–å„æ¨¡å—
        self.line_extractor = BuildingLineExtractor()
        self.matcher = LineFeatureMatcher(
            angle_threshold=10,    # å»ºç­‘ç‰©è§’åº¦æ›´ä¸¥æ ¼
            length_ratio=0.8
        )
        self.change_detector = ChangeDetector(match_threshold=0.6)

    def _default_config(self):
        """é»˜è®¤é…ç½®"""
        return {
            'edge_threshold': 30,
            'min_line_length': 50,
            'angle_threshold': 10,
            'match_threshold': 0.6,
            'violation_threshold': 0.5,
            'min_region_size': 100,  # æœ€å°è¿å»ºé¢ç§¯(åƒç´ )
        }

    def process(self, reference_img, current_img):
        """
        å¤„ç†å›¾åƒå¯¹,æ£€æµ‹è¿å»º

        Args:
            reference_img: å‚è€ƒæ—¶æœŸå›¾åƒ
            current_img: å½“å‰æ—¶æœŸå›¾åƒ

        Returns:
            result: {
                'has_violation': bool,
                'type': str,
                'regions': list of bbox,
                'visualizations': dict
            }
        """
        result = {
            'has_violation': False,
            'type': 'none',
            'regions': [],
            'visualizations': {}
        }

        # 1. æå–å»ºç­‘ç‰©çº¿ç‰¹å¾
        print("æå–å‚è€ƒå›¾åƒçº¿ç‰¹å¾...")
        lines_ref, ori_ref = self.line_extractor.extract_building_lines(reference_img)
        print(f"å‚è€ƒå›¾åƒæå–åˆ° {len(lines_ref)} æ¡çº¿æ®µ")

        print("æå–å½“å‰å›¾åƒçº¿ç‰¹å¾...")
        lines_cur, ori_cur = self.line_extractor.extract_building_lines(current_img)
        print(f"å½“å‰å›¾åƒæå–åˆ° {len(lines_cur)} æ¡çº¿æ®µ")

        # 2. å¯è§†åŒ–çº¿ç‰¹å¾
        result['visualizations']['ref_lines'] = self._visualize_lines(
            reference_img, lines_ref
        )
        result['visualizations']['cur_lines'] = self._visualize_lines(
            current_img, lines_cur
        )

        # 3. ç‰¹å¾åŒ¹é…
        print("åŒ¹é…çº¿ç‰¹å¾...")
        matches, scores = self.matcher.match(lines_ref, lines_cur)
        print(f"åŒ¹é…åˆ° {len(matches)} å¯¹çº¿æ®µ")

        # 4. å˜åŒ–æ£€æµ‹
        print("æ£€æµ‹å˜åŒ–...")
        changes = self.change_detector.detect_changes(
            matches, len(lines_ref), len(lines_cur)
        )

        # 5. åˆ†æè¿å»º
        print("åˆ†æè¿å»º...")
        analysis = self.change_detector.analyze_building_changes(changes)

        result['type'] = analysis['type']
        result['confidence'] = analysis['confidence']

        # 6. å®šä½è¿å»ºåŒºåŸŸ
        if analysis['confidence'] > self.config['violation_threshold']:
            result['has_violation'] = True

            # æ‰©å±•æ–°å¢çº¿æ®µå½¢æˆåŒºåŸŸ
            regions = self._form_regions_from_lines(
                lines_cur, changes['added']
            )

            # è¿‡æ»¤å°åŒºåŸŸ
            regions = self._filter_small_regions(regions)

            result['regions'] = regions

            # å¯è§†åŒ–å˜åŒ–
            result['visualizations']['change_map'] = self._visualize_changes(
                reference_img, current_img, changes, matches
            )

        return result

    def _visualize_lines(self, image, lines):
        """å¯è§†åŒ–çº¿ç‰¹å¾"""
        vis = image.copy()
        if len(vis.shape) == 2:
            vis = cv2.cvtColor(vis, cv2.COLOR_GRAY2BGR)

        for line in lines:
            start = tuple(map(int, line['start']))
            end = tuple(map(int, line['end']))
            color = (0, 255, 0)  # ç»¿è‰²
            cv2.line(vis, start, end, color, 2)

        return vis

    def _visualize_changes(self, img1, img2, changes, matches):
        """å¯è§†åŒ–å˜åŒ–"""
        h, w = img1.shape[:2]

        # å¹¶æ’æ˜¾ç¤º
        canvas = np.zeros((h, w*2, 3), dtype=np.uint8)
        canvas[:, :w] = cv2.cvtColor(img1, cv2.COLOR_GRAY2BGR)
        canvas[:, w:] = cv2.cvtColor(img2, cv2.COLOR_GRAY2BGR)

        # ç»˜åˆ¶åŒ¹é…çº¿
        for src_idx, tgt_idx in matches:
            # è¿™é‡Œç®€åŒ–å¤„ç†,å®é™…åº”è¯¥è·å–çº¿æ®µåæ ‡
            pass

        # æ ‡è®°æ–°å¢åŒºåŸŸ
        # ... (æ·»åŠ çº¢è‰²æ¡†æ ‡è®°)

        return canvas

    def _form_regions_from_lines(self, lines, line_indices):
        """
        ä»çº¿æ®µå½¢æˆåŒºåŸŸ

        Args:
            lines: æ‰€æœ‰çº¿æ®µ
            line_indices: æ–°å¢çº¿æ®µç´¢å¼•

        Returns:
            regions: åŒºåŸŸåˆ—è¡¨
        """
        # ç®€åŒ–å®ç°: å°†æ–°å¢çº¿æ®µæ‰©å±•ä¸ºçŸ©å½¢åŒºåŸŸ
        regions = []

        for idx in line_indices:
            if idx >= len(lines):
                continue

            line = lines[idx]
            start = line['start']
            end = line['end']

            # è®¡ç®—åŒ…å›´ç›’
            x_coords = [start[0], end[0]]
            y_coords = [start[1], end[1]]
            x_min, x_max = min(x_coords), max(x_coords)
            y_min, y_max = min(y_coords), max(y_coords)

            # æ‰©å±•
            margin = 50
            x_min = max(0, int(x_min - margin))
            x_max = min(10000, int(x_max + margin))
            y_min = max(0, int(y_min - margin))
            y_max = min(10000, int(y_max + margin))

            regions.append({
                'bbox': [x_min, y_min, x_max, y_max],
                'line_indices': [idx],
                'confidence': 0.8
            })

        return regions

    def _filter_small_regions(self, regions):
        """è¿‡æ»¤å°åŒºåŸŸ"""
        filtered = []
        for region in regions:
            bbox = region['bbox']
            area = (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])
            if area >= self.config['min_region_size']:
                filtered.append(region)
        return filtered
```

---

### ç»„ä»¶2: è®­ç»ƒæ•°æ®å‡†å¤‡

```python
class ViolationDatasetBuilder:
    """
    è¿å»ºæ£€æµ‹æ•°æ®é›†æ„å»ºå™¨
    """
    def __init__(self):
        self.image_pairs = []  # (ref_img, cur_img, annotation)

    def add_pair(self, ref_img, cur_img, annotations):
        """
        æ·»åŠ å›¾åƒå¯¹

        Args:
            ref_img: å‚è€ƒå›¾åƒ
            cur_img: å½“å‰å›¾åƒ
            annotations: {
                'new_buildings': [{'bbox': [x1,y1,x2,y2]}],
                'demolished': [{'bbox': [x1,y1,x2,y2]}]
            }
        """
        self.image_pairs.append({
            'reference': ref_img,
            'current': cur_img,
            'annotations': annotations
        })

    def export_for_training(self, output_dir):
        """
        å¯¼å‡ºè®­ç»ƒæ•°æ®
        """
        import os
        os.makedirs(output_dir, exist_ok=True)

        for idx, pair in enumerate(self.image_pairs):
            # ä¿å­˜å›¾åƒ
            cv2.imwrite(f"{output_dir}/ref_{idx}.png", pair['reference'])
            cv2.imwrite(f"{output_dir}/cur_{idx}.png", pair['current'])

            # ä¿å­˜æ ‡æ³¨
            import json
            with open(f"{output_dir}/ann_{idx}.json", 'w') as f:
                json.dump(pair['annotations'], f)
```

---

### ç»„ä»¶3: è¯„ä¼°æŒ‡æ ‡

```python
class ViolationMetrics:
    """
    è¿å»ºæ£€æµ‹è¯„ä¼°æŒ‡æ ‡
    """
    @staticmethod
def compute_metrics(predictions, ground_truth):
        """
        è®¡ç®—è¯„ä¼°æŒ‡æ ‡

        Args:
            predictions: é¢„æµ‹ç»“æœ
            ground_truth: çœŸå®æ ‡æ³¨

        Returns:
            metrics: {
                'precision': ç²¾ç¡®ç‡,
                'recall': å¬å›ç‡,
                'f1': F1åˆ†æ•°,
                'IoU': äº¤å¹¶æ¯”
            }
        """
        # ç»Ÿè®¡
        tp = 0  # True Positive (æ­£ç¡®æ£€æµ‹çš„è¿å»º)
        fp = 0  # False Positive (è¯¯æŠ¥)
        fn = 0  # False Negative (æ¼æ£€)

        ious = []

        # åŒ¹é…é¢„æµ‹å’ŒçœŸå®æ ‡æ³¨
        for pred in predictions:
            matched = False
            for gt in ground_truth:
                iou = ViolationMetrics.compute_iou(pred['bbox'], gt['bbox'])
                if iou > 0.5:  # IoUé˜ˆå€¼
                    matched = True
                    ious.append(iou)
                    break

            if matched:
                tp += 1
            else:
                fp += 1

        # è®¡ç®—æ¼æ£€
        fn = len(ground_truth) - tp

        # è®¡ç®—æŒ‡æ ‡
        precision = tp / (tp + fp + 1e-6)
        recall = tp / (tp + fn + 1e-6)
        f1 = 2 * precision * recall / (precision + recall + 1e-6)

        mean_iou = np.mean(ious) if ious else 0

        return {
            'precision': precision,
            'recall': recall,
            'f1': f1,
            'IoU': mean_iou
        }

    @staticmethod
    def compute_iou(box1, box2):
        """è®¡ç®—äº¤å¹¶æ¯”"""
        x1_min, y1_min, x1_max, y1_max = box1
        x2_min, y2_min, x2_max, y2_max = box2

        # è®¡ç®—äº¤é›†
        inter_xmin = max(x1_min, x2_min)
        inter_ymin = max(y1_min, y2_min)
        inter_xmax = min(x1_max, x2_max)
        inter_ymax = min(y1_max, y2_max)

        if inter_xmax < inter_xmin or inter_ymax < inter_ymin:
            return 0

        inter_area = (inter_xmax - inter_xmin) * (inter_ymax - inter_ymin)

        # è®¡ç®—å¹¶é›†
        area1 = (x1_max - x1_min) * (y1_max - y1_min)
        area2 = (x2_max - x2_min) * (y2_max - y2_min)
        union_area = area1 + area2 - inter_area

        return inter_area / union_area
```

---

## ğŸ“– å…³é”®æ¦‚å¿µä¸æœ¯è¯­

| æœ¯è¯­ | è‹±æ–‡ | è§£é‡Š |
|:---|:---|:---|
| **çº¿ç‰¹å¾** | Line Feature | å›¾åƒä¸­çš„ç›´çº¿æ®µç‰¹å¾ |
| **å½¢çŠ¶ä¸Šä¸‹æ–‡** | Shape Context | å¯¹æ•°æåæ ‡ç›´æ–¹å›¾æè¿°å­ |
| **éœå¤«å˜æ¢** | Hough Transform | ä»è¾¹ç¼˜æ£€æµ‹ç›´çº¿ |
| **Cannyè¾¹ç¼˜æ£€æµ‹** | Canny Edge Detection | è¾¹ç¼˜æ£€æµ‹ç®—æ³• |
| **å›¾åƒé…å‡†** | Image Registration | å›¾åƒå¯¹é½ |
| **å˜åŒ–æ£€æµ‹** | Change Detection | æ£€æµ‹å›¾åƒé—´å·®å¼‚ |
| **äº¤å¹¶æ¯”** | IoU (Intersection over Union) | é‡å åº¦åº¦é‡ |

---

## âœ… å¤ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£çº¿ç‰¹å¾æå–çš„æ–¹æ³•
- [ ] æŒæ¡å½¢çŠ¶ä¸Šä¸‹æ–‡æè¿°å­
- [ ] äº†è§£ç‰¹å¾åŒ¹é…çš„æµç¨‹
- [ ] ç†è§£å˜åŒ–æ£€æµ‹åŸç†
- [ ] èƒ½å°†æ–¹æ³•è¿ç§»åˆ°è¿å»ºæ£€æµ‹
- [ ] èƒ½å¤Ÿå®ç°åŸºæœ¬çš„æ£€æµ‹ç³»ç»Ÿ

---

## ğŸ¤” æ€è€ƒé—®é¢˜

1. **çº¿ç‰¹å¾ç›¸æ¯”ç‚¹ç‰¹å¾çš„ä¼˜åŠ¿ï¼Ÿ**
   - æç¤º: é¥æ„Ÿå›¾åƒä¸­å»ºç­‘ç‰©è¾¹ç¼˜æ¸…æ™°

2. **å¦‚ä½•å¤„ç†ä¸åŒåˆ†è¾¨ç‡çš„å›¾åƒï¼Ÿ**
   - æç¤º: å¤šå°ºåº¦åˆ†æ

3. **å¦‚ä½•åŒºåˆ†æ­£å¸¸å»ºç­‘å’Œè¿å»ºï¼Ÿ**
   - æç¤º: æ—¶åºå¯¹æ¯”ã€åŒºåŸŸåˆ†æ

4. **å¦‚ä½•é™ä½è¯¯æ£€ç‡ï¼Ÿ**
   - æç¤º: å¤šæ—¶ç›¸éªŒè¯ã€å‡ ä½•çº¦æŸ

---

## ğŸ”— ç›¸å…³è®ºæ–‡æ¨è

### å¿…è¯»
1. **LEVIR-CD** - é¥æ„Ÿå˜åŒ–æ£€æµ‹æ•°æ®é›†
2. **WHU Building** - å»ºç­‘æå–æ•°æ®é›†
3. **ISPRS** - æ‘„å½±æµ‹é‡ä¸é¥æ„ŸæœŸåˆŠ

### æ‰©å±•é˜…è¯»
1. **å»ºç­‘å˜åŒ–æ£€æµ‹ç»¼è¿°**
2. **é¥æ„Ÿå›¾åƒé…å‡†æ–¹æ³•**
3. **æ·±åº¦å­¦ä¹ åœ¨é¥æ„Ÿä¸­çš„åº”ç”¨**

---

**ç¬”è®°åˆ›å»ºæ—¶é—´**: 2026å¹´2æœˆ7æ—¥
**çŠ¶æ€**: å·²å®Œæˆç²¾è¯» âœ…
**ä¸‹ä¸€æ­¥**: å®ç°çº¿ç‰¹å¾æå–,åº”ç”¨äºè¿å»ºæ£€æµ‹
