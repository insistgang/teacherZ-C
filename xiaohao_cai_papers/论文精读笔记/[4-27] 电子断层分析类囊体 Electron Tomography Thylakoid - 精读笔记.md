# [4-27] ç”µå­æ–­å±‚åˆ†æç±»å›Šä½“ Electron Tomography Thylakoid - ç²¾è¯»ç¬”è®°

> **è®ºæ–‡æ ‡é¢˜**: Electron Tomography Analysis of Thylakoid Membranes
> **é˜…è¯»æ—¥æœŸ**: 2026å¹´2æœˆ10æ—¥
> **éš¾åº¦è¯„çº§**: â­â­â­ (ä¸­)
> **é‡è¦æ€§**: â­â­â­ (ç»†èƒç”Ÿç‰©å­¦æˆåƒ)

---

## ğŸ“‹ è®ºæ–‡åŸºæœ¬ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|:---|:---|
| **æ ‡é¢˜** | Electron Tomography Analysis of Thylakoid Membranes |
| **ä½œè€…** | Xiaohao Cai ç­‰äºº |
| **åº”ç”¨é¢†åŸŸ** | ç»†èƒç”Ÿç‰©å­¦ã€å…‰åˆè†œç ”ç©¶ |
| **å…³é”®è¯** | Electron Tomography, Thylakoid, Photosynthesis, 3D Structure |
| **æ ¸å¿ƒä»·å€¼** | ç±»å›Šä½“è†œç³»ç»Ÿçš„ä¸‰ç»´ç»“æ„è§£æ |

---

## ğŸ¯ æ ¸å¿ƒé—®é¢˜

### ç±»å›Šä½“(Thylakoid)ç®€ä»‹

```
ç±»å›Šä½“ç ”ç©¶èƒŒæ™¯:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ç±»å›Šä½“ (Thylakoid):
  - å¶ç»¿ä½“å†…éƒ¨çš„è†œç³»ç»Ÿ
  - å…‰åˆä½œç”¨çš„åœºæ‰€
  - åŒ…å«å…‰ç³»ç»ŸI/IIã€ç»†èƒè‰²ç´ b6få¤åˆç‰©ç­‰
  - ç»“æ„: åŸºç²’(grana) + åŸºè´¨ç‰‡å±‚(stroma lamellae)

ç ”ç©¶æ„ä¹‰:
  1. ç†è§£å…‰åˆä½œç”¨æœºåˆ¶
  2. å…‰èƒ½æ•è·ä¸è½¬æ¢
  3. ç”µå­ä¼ é€’é“¾ç»„ç»‡
  4. æ¤ç‰©é€‚åº”æ€§ç ”ç©¶

ç»“æ„å±‚æ¬¡:
  - åŸºç²’: å †å çš„è†œç›˜
  - åŸºè´¨ç‰‡å±‚: è¿æ¥åŸºç²’çš„è†œç®¡
  - è…”éš™(lumen): è†œå†…ç©ºé—´
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

### ä¸[4-26]å‰è´¨ä½“çš„å…³ç³»

| ç‰¹å¾ | å‰è´¨ä½“ (PLB) | ç±»å›Šä½“ (Thylakoid) |
|:---|:---|:---|
| **å‘è‚²é˜¶æ®µ** | å‰ä½“ | æˆç†ŸåŠŸèƒ½æ€ |
| **ç»“æ„** | ç®¡çŠ¶æ™¶æ ¼ | æ‰å¹³å›ŠçŠ¶å †å  |
| **åŠŸèƒ½** | å‘è‚²å‚¨å¤‡ | å…‰åˆä½œç”¨ |
| **è†œç‰¹å¾** | é«˜åº¦å¼¯æ›² | ç›¸å¯¹å¹³å¦ |

---

## ğŸ”¬ æ–¹æ³•è®º

### ç±»å›Šä½“ç»“æ„åˆ†ææµç¨‹

```
ç±»å›Šä½“ä¸‰ç»´åˆ†ææµç¨‹:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. æ ·å“åˆ¶å¤‡
   - æ¤ç‰©ææ–™å›ºå®š
   - é«˜å‹å†·å†» + å†·å†»æ›¿ä»£
   - è¶…è–„åˆ‡ç‰‡

2. ç”µå­æ–­å±‚æˆåƒ
   - å€¾æ–œç³»åˆ—é‡‡é›† (-65Â° to +65Â°)
   - åŒè½´å€¾æ–œ (æé«˜å®Œæ•´æ€§)

3. ä¸‰ç»´é‡å»º
   - å›¾åƒå¯¹é½
   - SIRTé‡å»º
   - å»å™ªå¤„ç†

4. ç»“æ„åˆ†å‰²
   - è†œåˆ†å‰²
   - åŸºç²’è¯†åˆ«
   - è¿æ¥åŒºåŸŸåˆ†æ

5. å®šé‡åˆ†æ
   - è†œæ›²ç‡
   - å †å ç¨‹åº¦
   - è¿é€šæ€§åˆ†æ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

---

### æ ¸å¿ƒç»„ä»¶: åŸºç²’-ç‰‡å±‚ç»“æ„åˆ†æ

```python
import numpy as np
from scipy import ndimage
from skimage import measure

class ThylakoidStructureAnalyzer:
    """
    ç±»å›Šä½“ç»“æ„åˆ†æå™¨

    åˆ†æåŸºç²’å’ŒåŸºè´¨ç‰‡å±‚çš„ä¸‰ç»´ç»“æ„
    """

    def __init__(self, voxel_size=1.0):
        self.voxel_size = voxel_size  # nm

    def analyze_grana_stacks(self, membrane_mask):
        """
        åˆ†æåŸºç²’å †å ç»“æ„

        Args:
            membrane_mask: è†œç»“æ„3Dæ©ç 

        Returns:
            grana_stats: åŸºç²’ç»Ÿè®¡ä¿¡æ¯
        """
        # è¯†åˆ«å †å åŒºåŸŸ
        stacked_regions = self.identify_stacked_regions(membrane_mask)

        # åˆ†ææ¯ä¸ªåŸºç²’
        grana_list = []
        for region_id in np.unique(stacked_regions)[1:]:  # è·³è¿‡èƒŒæ™¯
            granum_mask = stacked_regions == region_id

            granum_stats = self.analyze_single_granum(granum_mask)
            grana_list.append(granum_stats)

        return {
            'num_grana': len(grana_list),
            'grana_list': grana_list,
            'mean_diameter': np.mean([g['diameter'] for g in grana_list]),
            'mean_height': np.mean([g['height'] for g in grana_list]),
            'mean_num_layers': np.mean([g['num_layers'] for g in grana_list])
        }

    def identify_stacked_regions(self, membrane_mask):
        """
        è¯†åˆ«è†œå †å åŒºåŸŸ (åŸºç²’)

        åŸºäºè†œå¯†åº¦å’Œé—´è·
        """
        # è·ç¦»å˜æ¢
        distance = ndimage.distance_transform_edt(~membrane_mask)

        # è¯†åˆ«å †å : è†œé—´è·å°çš„åŒºåŸŸ
        # åŸºç²’ç‰¹å¾: è†œé—´è·çº¦3-5nm
        lumen_width = (distance > 2) & (distance < 6)

        # è¿é€šåˆ†é‡åˆ†æ
        labeled, num_features = ndimage.label(lumen_width)

        return labeled

    def analyze_single_granum(self, granum_mask):
        """åˆ†æå•ä¸ªåŸºç²’"""
        # è®¡ç®—å‡ ä½•ç‰¹å¾
        coords = np.argwhere(granum_mask)

        # è¾¹ç•Œæ¡†
        min_coords = coords.min(axis=0)
        max_coords = coords.max(axis=0)
        dimensions = max_coords - min_coords

        # ç­‰æ•ˆç›´å¾„
        volume = np.sum(granum_mask)
        diameter = 2 * (3 * volume / (4 * np.pi)) ** (1/3)

        # è®¡ç®—å±‚æ•° (æ²¿æœ€çŸ­è½´)
        min_axis = np.argmin(dimensions)
        num_layers = dimensions[min_axis] / 8  # å‡è®¾æ¯å±‚çº¦8nm (è†œ+è…”)

        return {
            'volume': volume * (self.voxel_size ** 3),
            'diameter': diameter * self.voxel_size,
            'height': dimensions[min_axis] * self.voxel_size,
            'num_layers': int(num_layers),
            'dimensions': dimensions * self.voxel_size
        }

    def analyze_stroma_lamellae(self, membrane_mask, grana_mask):
        """
        åˆ†æåŸºè´¨ç‰‡å±‚

        è¿æ¥åŸºç²’çš„éå †å è†œåŒºåŸŸ
        """
        # åŸºè´¨ç‰‡å±‚ = æ€»è†œ - åŸºç²’
        lamellae_mask = membrane_mask & ~grana_mask

        # éª¨æ¶åŒ–åˆ†æ
        from skimage.morphology import skeletonize_3d
        skeleton = skeletonize_3d(lamellae_mask)

        # åˆ†æè¿æ¥æ€§
        labeled, num_components = ndimage.label(skeleton)

        # è®¡ç®—æ¯ä¸ªç‰‡å±‚çš„é•¿åº¦
        lengths = []
        for i in range(1, num_components + 1):
            component = labeled == i
            length = np.sum(component)
            lengths.append(length * self.voxel_size)

        return {
            'total_length': np.sum(lengths),
            'num_branches': num_components,
            'mean_branch_length': np.mean(lengths) if lengths else 0,
            'max_branch_length': np.max(lengths) if lengths else 0
        }

    def compute_membrane_curvature(self, surface_mesh):
        """
        è®¡ç®—è†œæ›²ç‡

        åˆ†æè†œçš„å¼¯æ›²ç‰¹æ€§
        """
        vertices = surface_mesh['vertices']
        faces = surface_mesh['faces']

        # è®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„æ›²ç‡
        curvatures = []

        for i, vertex in enumerate(vertices):
            # æ‰¾åˆ°ç›¸é‚»é¢
            adjacent_faces = self.get_adjacent_faces(i, faces)

            # ä¼°è®¡æ³•å‘é‡å˜åŒ–
            normals = [self.compute_face_normal(f, vertices) for f in adjacent_faces]

            # æ›²ç‡ä¼°è®¡
            curvature = self.estimate_curvature_from_normals(normals)
            curvatures.append(curvature)

        return {
            'mean_curvature': np.mean(curvatures),
            'max_curvature': np.max(curvatures),
            'curvature_distribution': np.histogram(curvatures, bins=20)
        }

    def get_adjacent_faces(self, vertex_idx, faces):
        """è·å–ä¸é¡¶ç‚¹ç›¸é‚»çš„é¢"""
        return [f for f in faces if vertex_idx in f]

    def compute_face_normal(self, face, vertices):
        """è®¡ç®—é¢çš„æ³•å‘é‡"""
        v0 = vertices[face[0]]
        v1 = vertices[face[1]]
        v2 = vertices[face[2]]

        normal = np.cross(v1 - v0, v2 - v0)
        return normal / (np.linalg.norm(normal) + 1e-10)

    def estimate_curvature_from_normals(self, normals):
        """ä»æ³•å‘é‡å˜åŒ–ä¼°è®¡æ›²ç‡"""
        if len(normals) < 2:
            return 0

        # æ³•å‘é‡æ–¹å·®ä½œä¸ºæ›²ç‡ä¼°è®¡
        mean_normal = np.mean(normals, axis=0)
        variances = [np.linalg.norm(n - mean_normal) for n in normals]

        return np.mean(variances)
```

---

### å…‰åˆä½œç”¨å¤åˆç‰©å®šä½

```python
class PhotosystemLocator:
    """
    å…‰åˆå¤åˆç‰©å®šä½åˆ†æ

    åœ¨ç±»å›Šä½“è†œä¸Šå®šä½PSIã€PSIIç­‰å¤åˆç‰©
    """

    def __init__(self):
        self.ps_size = {  # å¤åˆç‰©å°ºå¯¸ (nm)
            'PSII': 15,
            'PSI': 12,
            'Cyt_b6f': 8,
            'ATP_synthase': 20
        }

    def locate_complexes(self, tomogram, membrane_mask):
        """
        å®šä½è†œè›‹ç™½å¤åˆç‰©

        Args:
            tomogram: 3Dæ–­å±‚å›¾åƒ
            membrane_mask: è†œæ©ç 

        Returns:
            locations: å¤åˆç‰©ä½ç½®åˆ—è¡¨
        """
        # æ¨¡æ¿åŒ¹é…æ£€æµ‹
        complexes = []

        for name, size in self.ps_size.items():
            template = self.create_template(size)

            # åœ¨è†œåŒºåŸŸè¿›è¡Œæ¨¡æ¿åŒ¹é…
            matches = self.template_match(tomogram, template, membrane_mask)

            for match in matches:
                complexes.append({
                    'type': name,
                    'position': match['position'],
                    'confidence': match['score']
                })

        return complexes

    def create_template(self, size_nm):
        """åˆ›å»ºè›‹ç™½å¤åˆç‰©æ¨¡æ¿"""
        # ç®€åŒ–ä¸ºé«˜æ–¯çƒ
        size_voxels = int(size_nm / 2)  # å‡è®¾2nm/åƒç´ 

        x = np.linspace(-size_voxels, size_voxels, 2*size_voxels+1)
        X, Y, Z = np.meshgrid(x, x, x)

        R = np.sqrt(X**2 + Y**2 + Z**2)
        template = np.exp(-R**2 / (2 * (size_voxels/2)**2))

        return template

    def template_match(self, tomogram, template, mask):
        """æ¨¡æ¿åŒ¹é…"""
        from scipy.signal import correlate

        # ä»…åœ¨è†œåŒºåŸŸè¿›è¡ŒåŒ¹é…
        matches = []

        # å½’ä¸€åŒ–äº’ç›¸å…³
        correlation = correlate(tomogram, template, mode='same')

        # æ‰¾åˆ°å±€éƒ¨æå¤§å€¼
        from scipy.ndimage import maximum_filter
        local_max = (correlation == maximum_filter(correlation, size=10))

        # æå–å³°å€¼
        peak_indices = np.argwhere(local_max & mask)

        for idx in peak_indices[:50]:  # å–å‰50ä¸ª
            score = correlation[tuple(idx)]
            if score > 0.5:  # é˜ˆå€¼
                matches.append({
                    'position': idx,
                    'score': score
                })

        return matches

    def analyze_spatial_distribution(self, complexes):
        """
        åˆ†æå¤åˆç‰©çš„ç©ºé—´åˆ†å¸ƒ
        """
        # æŒ‰ç±»å‹åˆ†ç»„
        by_type = {}
        for c in complexes:
            t = c['type']
            if t not in by_type:
                by_type[t] = []
            by_type[t].append(c['position'])

        # è®¡ç®—å„ç±»å‹çš„åˆ†å¸ƒç‰¹å¾
        distributions = {}
        for t, positions in by_type.items():
            positions = np.array(positions)

            # æœ€è¿‘é‚»è·ç¦»
            from scipy.spatial.distance import pdist
            distances = pdist(positions)

            distributions[t] = {
                'count': len(positions),
                'mean_nn_distance': np.mean(distances) if len(distances) > 0 else 0,
                'density': len(positions) / np.prod(positions.max(axis=0) - positions.min(axis=0))
            }

        return distributions
```

---

## ğŸ“Š å®éªŒç»“æœ

### ç±»å›Šä½“ç»“æ„å‚æ•°

| ç‰¹å¾ | æµ‹é‡å€¼ | ç”Ÿç‰©å­¦æ„ä¹‰ |
|:---|:---:|:---|
| **åŸºç²’ç›´å¾„** | 300-600 nm | å…‰æ•è·æ•ˆç‡ |
| **åŸºç²’å±‚æ•°** | 3-10å±‚ | å †å ç¨‹åº¦ |
| **å±‚é—´è·** | 3-5 nm | è†œé—´ç›¸äº’ä½œç”¨ |
| **åŸºè´¨ç‰‡å±‚å®½åº¦** | 10-20 nm | æ‰©æ•£é€šé“ |
| **PSIIå¯†åº¦** | ~500/Î¼mÂ² | å…‰èƒ½æ•è· |

### ç»“æ„-åŠŸèƒ½å…³ç³»

```
ç±»å›Šä½“ç»“æ„-åŠŸèƒ½å…³ç³»:

åŸºç²’å †å  â†â”€â”€â”€â”€â†’ å…‰æ•è·æ•ˆç‡
   â†‘                  â†‘
   â”‚ æ›´å¤šå±‚æ•° = æ›´å¤šè‰²ç´ è›‹ç™½
   â”‚
åŸºè´¨ç‰‡å±‚ â†â”€â”€â”€â”€â†’ ç”µå­ä¼ é€’
   â†‘                  â†‘
   â”‚ è¿æ¥åŸºç²’,å½¢æˆè¿ç»­ç½‘ç»œ
   â”‚
è†œæ›²ç‡ â†â”€â”€â”€â”€â†’ è›‹ç™½å®šä½
   â†‘                  â†‘
   â”‚ é«˜æ›²ç‡åŒºåŸŸå¯Œé›†ç‰¹å®šå¤åˆç‰©
```

---

## ğŸ’¡ å¯¹äº•ç›–æ£€æµ‹çš„å¯ç¤º

### å±‚æ¬¡åŒ–ç»“æ„åˆ†æ

```python
class HierarchicalStructureAnalysis:
    """
    å€Ÿé‰´ç±»å›Šä½“åˆ†æçš„å±‚æ¬¡åŒ–ç»“æ„åˆ†ææ–¹æ³•

    ç”¨äºå¤æ‚åœºæ™¯çš„ç†è§£
    """

    def __init__(self):
        self.levels = ['pixel', 'region', 'object', 'scene']

    def analyze(self, image):
        """
        å±‚æ¬¡åŒ–åˆ†æ

        ç±»ä¼¼ç±»å›Šä½“çš„å¤šå°ºåº¦ç»“æ„åˆ†æ
        """
        # Level 1: åƒç´ çº§ç‰¹å¾
        pixel_features = self.extract_pixel_features(image)

        # Level 2: åŒºåŸŸåˆ†å‰²
        regions = self.segment_regions(pixel_features)

        # Level 3: å¯¹è±¡è¯†åˆ«
        objects = self.identify_objects(regions)

        # Level 4: åœºæ™¯ç†è§£
        scene = self.understand_scene(objects)

        return {
            'pixel': pixel_features,
            'regions': regions,
            'objects': objects,
            'scene': scene
        }

    def extract_pixel_features(self, image):
        """åƒç´ çº§ç‰¹å¾"""
        # é¢œè‰²ã€çº¹ç†ã€è¾¹ç¼˜
        pass

    def segment_regions(self, features):
        """åŒºåŸŸåˆ†å‰²"""
        # ç±»ä¼¼è†œåˆ†å‰²
        pass

    def identify_objects(self, regions):
        """å¯¹è±¡è¯†åˆ«"""
        # åœ¨åŒºåŸŸä¸­è¯†åˆ«ç›®æ ‡
        pass

    def understand_scene(self, objects):
        """åœºæ™¯ç†è§£"""
        # å¯¹è±¡é—´å…³ç³»åˆ†æ
        pass
```

---

## ğŸ“– å…³é”®æ¦‚å¿µä¸æœ¯è¯­

| æœ¯è¯­ | è‹±æ–‡ | è§£é‡Š |
|:---|:---|:---|
| **ç±»å›Šä½“** | Thylakoid | å¶ç»¿ä½“å†…çš„å…‰åˆè†œç³»ç»Ÿ |
| **åŸºç²’** | Granum | å †å çš„ç±»å›Šä½“è†œç›˜ |
| **åŸºè´¨ç‰‡å±‚** | Stroma Lamella | è¿æ¥åŸºç²’çš„éå †å è†œ |
| **å…‰ç³»ç»Ÿ** | Photosystem | å…‰åˆè‰²ç´ -è›‹ç™½å¤åˆç‰© |
| **è…”éš™** | Lumen | ç±»å›Šä½“è†œå†…ç©ºé—´ |

---

## âœ… å¤ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£ç±»å›Šä½“ç»“æ„ç‰¹ç‚¹
- [ ] æŒæ¡åŸºç²’-ç‰‡å±‚åˆ†ææ–¹æ³•
- [ ] äº†è§£è†œè›‹ç™½å®šä½æŠ€æœ¯
- [ ] ç†è§£ç»“æ„-åŠŸèƒ½å…³ç³»åˆ†æ

---

**ç¬”è®°åˆ›å»ºæ—¶é—´**: 2026å¹´2æœˆ10æ—¥
**çŠ¶æ€**: å·²å®Œæˆç²¾è¯» âœ…
