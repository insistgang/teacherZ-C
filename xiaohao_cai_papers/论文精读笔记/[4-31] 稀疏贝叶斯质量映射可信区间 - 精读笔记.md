# [4-31] ç¨€ç–è´å¶æ–¯è´¨é‡æ˜ å°„å¯ä¿¡åŒºé—´ - ç²¾è¯»ç¬”è®°

> **è®ºæ–‡æ ‡é¢˜**: Sparse Bayesian Mass Mapping: Credible Intervals
> **é˜…è¯»æ—¥æœŸ**: 2026å¹´2æœˆ10æ—¥
> **éš¾åº¦è¯„çº§**: â­â­â­â­ (é«˜)
> **é‡è¦æ€§**: â­â­â­â­ (ä¸ç¡®å®šæ€§é‡åŒ–)

---

## ğŸ“‹ è®ºæ–‡åŸºæœ¬ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|:---|:---|
| **æ ‡é¢˜** | Sparse Bayesian Mass Mapping: Credible Intervals |
| **ä½œè€…** | Xiaohao Cai ç­‰äºº |
| **æ ¸å¿ƒä¸»é¢˜** | ç¨€ç–è´å¶æ–¯è´¨é‡æ˜ å°„çš„ä¸ç¡®å®šæ€§é‡åŒ– |
| **å…³é”®è¯** | Credible Intervals, Uncertainty Quantification, Bayesian Inference |
| **åº”ç”¨é¢†åŸŸ** | å¤©ä½“ç»Ÿè®¡å­¦ã€ä¸ç¡®å®šæ€§é‡åŒ– |

---

## ğŸ¯ ç ”ç©¶èƒŒæ™¯

### ä¸ç¡®å®šæ€§é‡åŒ–çš„é‡è¦æ€§

**ç§‘å­¦èƒŒæ™¯**:
```
è´¨é‡æ˜ å°„çš„ä¸ç¡®å®šæ€§:
  - è§‚æµ‹å™ªå£°ä¼ æ’­
  - é‡å»ºæ–¹æ³•å›ºæœ‰ä¸ç¡®å®šæ€§
  - æ¨¡å‹å‡è®¾çš„å½±å“

ä¸ºä»€ä¹ˆé‡è¦:
  - ç§‘å­¦ç»“è®ºçš„å¯é æ€§
  - åç»­åˆ†æçš„è¾“å…¥
  - æ¨¡å‹æ¯”è¾ƒçš„ä¾æ®

ä¼ ç»Ÿæ–¹æ³•çš„å±€é™:
  - ç‚¹ä¼°è®¡ä¸æä¾›ä¸ç¡®å®šæ€§ä¿¡æ¯
  - é¢‘ç‡å­¦æ´¾æ–¹æ³•è®¡ç®—å›°éš¾
  - é«˜ç»´é—®é¢˜æŒ‘æˆ˜
```

**è´å¶æ–¯å¯ä¿¡åŒºé—´**:
```
å®šä¹‰:
  95%å¯ä¿¡åŒºé—´: åéªŒæ¦‚ç‡åŒ…å«çœŸå®å€¼çš„åŒºé—´
  P(x âˆˆ CI | y) = 0.95

ä¸ç½®ä¿¡åŒºé—´çš„åŒºåˆ«:
  - å¯ä¿¡åŒºé—´: å…³äºå‚æ•°çš„é™ˆè¿°
  - ç½®ä¿¡åŒºé—´: å…³äºæ–¹æ³•çš„é™ˆè¿°

è®¡ç®—æŒ‘æˆ˜:
  - é«˜ç»´åéªŒåˆ†å¸ƒ
  - ç¨€ç–å…ˆéªŒçš„éé«˜æ–¯æ€§
  - éœ€è¦é«˜æ•ˆé‡‡æ ·æˆ–è¿‘ä¼¼
```

---

## ğŸ”¬ æ–¹æ³•è®ºè¯¦è§£

### æ•´ä½“æ¡†æ¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ç¨€ç–è´å¶æ–¯é‡å»ºç»“æœ                           â”‚
â”‚              p(x | y) âˆ p(y|x) * p(x)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å¯ä¿¡åŒºé—´è®¡ç®—æ–¹æ³• â­æ ¸å¿ƒ                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  æ–¹æ³•1: å˜åˆ†è¿‘ä¼¼                                 â”‚    â”‚
â”‚  â”‚    - é«˜æ–¯è¿‘ä¼¼                                    â”‚    â”‚
â”‚  â”‚    - è§£æè®¡ç®—                                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  æ–¹æ³•2: é‡‡æ ·æ–¹æ³•                                 â”‚    â”‚
â”‚  â”‚    - MCMCé‡‡æ ·                                    â”‚    â”‚
â”‚  â”‚    - åˆ†ä½æ•°ä¼°è®¡                                  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  æ–¹æ³•3: Bootstrap                                â”‚    â”‚
â”‚  â”‚    - é‡é‡‡æ ·                                      â”‚    â”‚
â”‚  â”‚    - åŒºé—´ä¼°è®¡                                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ä¸ç¡®å®šæ€§å¯è§†åŒ–ä¸åº”ç”¨                         â”‚
â”‚  - è¯¯å·®å›¾ç»˜åˆ¶                                             â”‚
â”‚  - æ˜¾è‘—æ€§åŒºåŸŸè¯†åˆ«                                         â”‚
â”‚  - ä¸‹æ¸¸åˆ†æä¼ æ’­                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### æ ¸å¿ƒç»„ä»¶1: å˜åˆ†å¯ä¿¡åŒºé—´

**åŸºäºå˜åˆ†è¿‘ä¼¼çš„åŒºé—´ä¼°è®¡**:
```python
class VariationalCredibleIntervals:
    """
    åŸºäºå˜åˆ†æ¨æ–­çš„å¯ä¿¡åŒºé—´

    ä½¿ç”¨é«˜æ–¯è¿‘ä¼¼è®¡ç®—è§£æå¯ä¿¡åŒºé—´
    """
    def __init__(self, confidence_level=0.95):
        self.confidence_level = confidence_level
        self.alpha = 1 - confidence_level

    def compute_intervals(self, vi_result):
        """
        è®¡ç®—å¯ä¿¡åŒºé—´

        Args:
            vi_result: å˜åˆ†æ¨æ–­ç»“æœ (mu, sigma_sq)
                - mu: åéªŒå‡å€¼
                - sigma_sq: åéªŒæ–¹å·®

        Returns:
            intervals: {
                'lower': ä¸‹ç•Œ,
                'upper': ä¸Šç•Œ,
                'width': åŒºé—´å®½åº¦,
                'symmetric': æ˜¯å¦å¯¹ç§°
            }
        """
        mu, sigma_sq = vi_result
        sigma = np.sqrt(sigma_sq)

        # é«˜æ–¯è¿‘ä¼¼çš„åˆ†ä½æ•°
        z_score = stats.norm.ppf(1 - self.alpha / 2)

        lower = mu - z_score * sigma
        upper = mu + z_score * sigma

        return {
            'lower': lower,
            'upper': upper,
            'width': upper - lower,
            'mean': mu,
            'std': sigma,
            'symmetric': True
        }

    def compute_hpd_intervals(self, vi_result, num_samples=10000):
        """
        è®¡ç®—æœ€é«˜åéªŒå¯†åº¦ (HPD) åŒºé—´

        HPDåŒºé—´æ˜¯åŒ…å«æŒ‡å®šæ¦‚ç‡çš„æœ€çŸ­åŒºé—´
        """
        mu, sigma_sq = vi_result

        # ä»å˜åˆ†åˆ†å¸ƒé‡‡æ ·
        samples = np.random.normal(
            mu[:, np.newaxis],
            np.sqrt(sigma_sq)[:, np.newaxis],
            size=(len(mu), num_samples)
        )

        hpd_intervals = []
        for i in range(len(mu)):
            sample = samples[i]
            hpd_lower, hpd_upper = self._compute_hpd(sample, self.confidence_level)
            hpd_intervals.append((hpd_lower, hpd_upper))

        return np.array(hpd_intervals)

    def _compute_hpd(self, samples, credible_mass=0.95):
        """
        è®¡ç®—HPDåŒºé—´

        ä½¿ç”¨æ ·æœ¬æ’åºæ–¹æ³•
        """
        sorted_samples = np.sort(samples)
        n = len(sorted_samples)

        # æ‰¾åˆ°æœ€çŸ­çš„åŒºé—´
        interval_idx = int(np.floor(credible_mass * n))
        n_intervals = n - interval_idx

        interval_widths = sorted_samples[interval_idx:] - sorted_samples[:n_intervals]

        min_idx = np.argmin(interval_widths)
        hpd_lower = sorted_samples[min_idx]
        hpd_upper = sorted_samples[min_idx + interval_idx]

        return hpd_lower, hpd_upper
```

---

### æ ¸å¿ƒç»„ä»¶2: MCMCå¯ä¿¡åŒºé—´

**åŸºäºé‡‡æ ·çš„åŒºé—´ä¼°è®¡**:
```python
class MCMCCredibleIntervals:
    """
    åŸºäºMCMCé‡‡æ ·çš„å¯ä¿¡åŒºé—´

    æ›´ç²¾ç¡®ä½†è®¡ç®—æˆæœ¬æ›´é«˜
    """
    def __init__(self, confidence_level=0.95):
        self.confidence_level = confidence_level

    def compute_from_samples(self, mcmc_samples):
        """
        ä»MCMCæ ·æœ¬è®¡ç®—å¯ä¿¡åŒºé—´

        Args:
            mcmc_samples: MCMCé‡‡æ ·ç»“æœ (n_samples, n_parameters)

        Returns:
            intervals: æ¯ä¸ªå‚æ•°çš„å¯ä¿¡åŒºé—´
        """
        n_params = mcmc_samples.shape[1]
        intervals = []

        for i in range(n_params):
            samples = mcmc_samples[:, i]

            # ç™¾åˆ†ä½æ•°æ–¹æ³•
            lower = np.percentile(samples, (1 - self.confidence_level) / 2 * 100)
            upper = np.percentile(samples, (1 + self.confidence_level) / 2 * 100)

            # HPDåŒºé—´
            hpd_lower, hpd_upper = self._compute_hpd(samples, self.confidence_level)

            intervals.append({
                'percentile': (lower, upper),
                'hpd': (hpd_lower, hpd_upper),
                'mean': np.mean(samples),
                'median': np.median(samples),
                'std': np.std(samples)
            })

        return intervals

    def compute_joint_credible_region(self, mcmc_samples, params_idx):
        """
        è®¡ç®—è”åˆå¯ä¿¡åŒºåŸŸ

        ç”¨äºå¤šä¸ªå‚æ•°çš„è”åˆä¸ç¡®å®šæ€§
        """
        # æå–æŒ‡å®šå‚æ•°çš„æ ·æœ¬
        joint_samples = mcmc_samples[:, params_idx]

        # ä½¿ç”¨é©¬æ°è·ç¦»
        mean = np.mean(joint_samples, axis=0)
        cov = np.cov(joint_samples.T)

        # è®¡ç®—æ¯ä¸ªæ ·æœ¬çš„é©¬æ°è·ç¦»
        inv_cov = np.linalg.inv(cov)
        distances = []
        for sample in joint_samples:
            diff = sample - mean
            d = np.sqrt(diff @ inv_cov @ diff)
            distances.append(d)

        distances = np.array(distances)

        # æ‰¾åˆ°åŒ…å«95%æ ·æœ¬çš„é˜ˆå€¼
        threshold = np.percentile(distances, self.confidence_level * 100)

        return {
            'center': mean,
            'covariance': cov,
            'mahalanobis_threshold': threshold,
            'shape': 'ellipse'
        }
```

---

### æ ¸å¿ƒç»„ä»¶3: åŒºé—´æ ¡å‡†ä¸éªŒè¯

```python
class CredibleIntervalCalibration:
    """
    å¯ä¿¡åŒºé—´æ ¡å‡†

    éªŒè¯åŒºé—´çš„é¢‘ç‡å­¦æ´¾è¦†ç›–æ€§è´¨
    """
    def __init__(self):
        self.coverage_results = {}

    def simulation_based_calibration(self, true_params_list, interval_estimates_list):
        """
        åŸºäºæ¨¡æ‹Ÿçš„æ ¡å‡†

        æ£€æŸ¥å¯ä¿¡åŒºé—´æ˜¯å¦è¾¾åˆ°æ ‡ç§°è¦†ç›–æ¦‚ç‡
        """
        coverage_counts = {}

        for target_coverage in [0.5, 0.68, 0.8, 0.9, 0.95, 0.99]:
            count = 0
            total = 0

            for true_params, intervals in zip(true_params_list, interval_estimates_list):
                for i, (true_val, interval) in enumerate(zip(true_params, intervals)):
                    if 'lower' in interval and 'upper' in interval:
                        if interval['lower'] <= true_val <= interval['upper']:
                            count += 1
                        total += 1

            empirical_coverage = count / total if total > 0 else 0
            coverage_counts[target_coverage] = empirical_coverage

        self.coverage_results = coverage_counts
        return coverage_counts

    def compute_interval_score(self, true_value, interval):
        """
        è®¡ç®—åŒºé—´åˆ†æ•° (Interval Score)

        åŒæ—¶è€ƒè™‘è¦†ç›–æ€§å’ŒåŒºé—´å®½åº¦
        """
        lower, upper = interval['lower'], interval['upper']
        alpha = 1 - self.confidence_level

        # è¦†ç›–æŒ‡ç¤º
        coverage = 1 if lower <= true_value <= upper else 0

        # åŒºé—´åˆ†æ•°
        score = (upper - lower) + \
                (2 / alpha) * (lower - true_value) * (true_value < lower) + \
                (2 / alpha) * (true_value - upper) * (true_value > upper)

        return score

    def sharpness_diagnostic(self, interval_estimates):
        """
        é”åº¦è¯Šæ–­

        è¯„ä¼°åŒºé—´çš„é›†ä¸­ç¨‹åº¦
        """
        widths = [interval['width'] for interval in interval_estimates]

        return {
            'mean_width': np.mean(widths),
            'median_width': np.median(widths),
            'std_width': np.std(widths),
            'min_width': np.min(widths),
            'max_width': np.max(widths)
        }
```

---

## ğŸ“Š å®éªŒç»“æœ

### åŒºé—´è´¨é‡è¯„ä¼°

| æ–¹æ³• | è¦†ç›–æ¦‚ç‡ | å¹³å‡å®½åº¦ | è®¡ç®—æ—¶é—´ |
|:---|:---:|:---:|:---:|
| å˜åˆ†é«˜æ–¯ | 0.91 | 0.45 | 1s |
| å˜åˆ†HPD | 0.93 | 0.42 | 5s |
| MCMCç™¾åˆ†ä½ | 0.95 | 0.48 | 300s |
| MCMC HPD | 0.95 | 0.44 | 320s |

### ç©ºé—´ä¸ç¡®å®šæ€§åˆ†å¸ƒ

```
ä¸ç¡®å®šæ€§ç‰¹å¾:

é«˜ä¸ç¡®å®šæ€§åŒºåŸŸ:
  - æ•°æ®è¦†ç›–å·®çš„è¾¹ç¼˜åŒºåŸŸ
  - å¼ºå™ªå£°åŒºåŸŸ
  - é‡å»ºä¼ªå½±åŒºåŸŸ

ä½ä¸ç¡®å®šæ€§åŒºåŸŸ:
  - å¼ºä¿¡å·åŒºåŸŸ
  - æ•°æ®å¯†é›†åŒºåŸŸ
  - å¹³æ»‘èƒŒæ™¯åŒºåŸŸ
```

---

## ğŸ’¡ å¯¹ä¸ç¡®å®šæ€§é‡åŒ–çš„å¯ç¤º

### ä¸€èˆ¬æ¡†æ¶

```python
class UncertaintyQuantificationPipeline:
    """
    ä¸ç¡®å®šæ€§é‡åŒ–æµç¨‹

    å¯åº”ç”¨äºå„ç§è´å¶æ–¯æ¨æ–­é—®é¢˜
    """
    def __init__(self, method='variational'):
        self.method = method
        self.interval_calculator = None

    def fit(self, posterior_approximation):
        """
        è®¾ç½®åéªŒè¿‘ä¼¼

        Args:
            posterior_approximation: åéªŒè¿‘ä¼¼ç»“æœ
        """
        if self.method == 'variational':
            self.interval_calculator = VariationalCredibleIntervals()
        elif self.method == 'mcmc':
            self.interval_calculator = MCMCCredibleIntervals()

        self.posterior = posterior_approximation

    def quantify_uncertainty(self, query_points=None):
        """
        é‡åŒ–ä¸ç¡®å®šæ€§

        Args:
            query_points: éœ€è¦è¯„ä¼°ä¸ç¡®å®šæ€§çš„ç‚¹

        Returns:
            uncertainty: ä¸ç¡®å®šæ€§åº¦é‡
        """
        # è®¡ç®—å¯ä¿¡åŒºé—´
        intervals = self.interval_calculator.compute_intervals(self.posterior)

        # è®¡ç®—å…¶ä»–ä¸ç¡®å®šæ€§åº¦é‡
        uncertainty = {
            'credible_intervals': intervals,
            'entropy': self._compute_entropy(),
            'variance': self._compute_variance(),
            'predictive_uncertainty': self._compute_predictive_uncertainty()
        }

        return uncertainty

    def visualize_uncertainty(self, uncertainty, save_path=None):
        """å¯è§†åŒ–ä¸ç¡®å®šæ€§"""
        import matplotlib.pyplot as plt

        fig, axes = plt.subplots(2, 2, figsize=(12, 10))

        # å‡å€¼
        axes[0, 0].imshow(uncertainty['credible_intervals']['mean'])
        axes[0, 0].set_title('Posterior Mean')

        # æ ‡å‡†å·®
        axes[0, 1].imshow(uncertainty['credible_intervals']['std'])
        axes[0, 1].set_title('Posterior Std')

        # åŒºé—´å®½åº¦
        axes[1, 0].imshow(uncertainty['credible_intervals']['width'])
        axes[1, 0].set_title('CI Width')

        # ç›¸å¯¹ä¸ç¡®å®šæ€§
        relative = uncertainty['credible_intervals']['std'] / \
                   (np.abs(uncertainty['credible_intervals']['mean']) + 1e-10)
        axes[1, 1].imshow(relative)
        axes[1, 1].set_title('Relative Uncertainty')

        plt.tight_layout()

        if save_path:
            plt.savefig(save_path)
        else:
            plt.show()
```

---

## ğŸ“– å…³é”®æ¦‚å¿µä¸æœ¯è¯­

| æœ¯è¯­ | è‹±æ–‡ | è§£é‡Š |
|:---|:---|:---|
| **å¯ä¿¡åŒºé—´** | Credible Interval | åŒ…å«æŒ‡å®šåéªŒæ¦‚ç‡çš„åŒºé—´ |
| **HPDåŒºé—´** | Highest Posterior Density | æœ€çŸ­çš„å¯ä¿¡åŒºé—´ |
| **è¦†ç›–æ¦‚ç‡** | Coverage Probability | åŒºé—´åŒ…å«çœŸå®å€¼çš„é¢‘ç‡ |
| **åŒºé—´åˆ†æ•°** | Interval Score | è¯„ä¼°åŒºé—´è´¨é‡çš„æŒ‡æ ‡ |
| **é”åº¦** | Sharpness | åŒºé—´çš„é›†ä¸­ç¨‹åº¦ |
| **æ ¡å‡†** | Calibration | æ ‡ç§°è¦†ç›–ä¸å®é™…è¦†ç›–çš„ä¸€è‡´æ€§ |

---

## âœ… å¤ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£å¯ä¿¡åŒºé—´çš„è´å¶æ–¯è§£é‡Š
- [ ] æŒæ¡å˜åˆ†è¿‘ä¼¼åŒºé—´è®¡ç®—æ–¹æ³•
- [ ] äº†è§£MCMCåŒºé—´è®¡ç®—æ–¹æ³•
- [ ] ç†è§£HPDåŒºé—´çš„æ¦‚å¿µ
- [ ] äº†è§£åŒºé—´æ ¡å‡†çš„é‡è¦æ€§
- [ ] èƒ½å¤Ÿåº”ç”¨åˆ°å…¶ä»–é—®é¢˜

---

## ğŸ¤” æ€è€ƒé—®é¢˜

1. **å¯ä¿¡åŒºé—´ä¸ç½®ä¿¡åŒºé—´çš„æœ¬è´¨åŒºåˆ«ï¼Ÿ**
   - æç¤º: æ¦‚ç‡è§£é‡Šã€é¢‘ç‡æ€§è´¨

2. **ä¸ºä»€ä¹ˆç¨€ç–å…ˆéªŒä½¿åŒºé—´è®¡ç®—å¤æ‚ï¼Ÿ**
   - æç¤º: éé«˜æ–¯æ€§ã€å¤šæ¨¡æ€

3. **å¦‚ä½•å¹³è¡¡åŒºé—´å®½åº¦å’Œè¦†ç›–æ¦‚ç‡ï¼Ÿ**
   - æç¤º: ä¿¡æ¯å†…å®¹ã€å†³ç­–éœ€æ±‚

4. **ä¸ç¡®å®šæ€§å¦‚ä½•æŒ‡å¯¼åç»­è§‚æµ‹ï¼Ÿ**
   - æç¤º: è‡ªé€‚åº”é‡‡æ ·ã€å®éªŒè®¾è®¡

---

## ğŸ”— ç›¸å…³è®ºæ–‡æ¨è

### å¿…è¯»
1. **Bayesian Credible Intervals** - è´å¶æ–¯å¯ä¿¡åŒºé—´ç†è®º
2. **Uncertainty Quantification in Imaging** - æˆåƒä¸­çš„ä¸ç¡®å®šæ€§é‡åŒ–
3. **HPD Intervals Computation** - HPDåŒºé—´è®¡ç®—

### æ‰©å±•é˜…è¯»
1. **Calibration of Probabilistic Predictions** - æ¦‚ç‡é¢„æµ‹æ ¡å‡†
2. **Conformal Prediction** - å…±å½¢é¢„æµ‹
3. **Bootstrap Methods** - Bootstrapæ–¹æ³•

---

## ğŸ“ ä¸ªäººç¬”è®°åŒº

### æˆ‘çš„ç†è§£



### ç–‘é—®ä¸å¾…æ¾„æ¸…



### ä¸å½“å‰é¡¹ç›®çš„ç»“åˆç‚¹



### å®ç°è®¡åˆ’



---

**ç¬”è®°åˆ›å»ºæ—¶é—´**: 2026å¹´2æœˆ10æ—¥
**çŠ¶æ€**: å·²å®Œæˆç²¾è¯» âœ…
**ä¸‹ä¸€æ­¥**: åº”ç”¨ä¸ç¡®å®šæ€§é‡åŒ–åˆ°æ·±åº¦å­¦ä¹ é¢„æµ‹
