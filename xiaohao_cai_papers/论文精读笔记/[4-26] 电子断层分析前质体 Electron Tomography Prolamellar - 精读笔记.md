# [4-26] ç”µå­æ–­å±‚åˆ†æå‰è´¨ä½“ Electron Tomography Prolamellar - ç²¾è¯»ç¬”è®°

> **è®ºæ–‡æ ‡é¢˜**: Electron Tomography Analysis of Prolamellar Bodies
> **é˜…è¯»æ—¥æœŸ**: 2026å¹´2æœˆ10æ—¥
> **éš¾åº¦è¯„çº§**: â­â­â­ (ä¸­)
> **é‡è¦æ€§**: â­â­â­ (ç»†èƒç”Ÿç‰©å­¦æˆåƒ)

---

## ğŸ“‹ è®ºæ–‡åŸºæœ¬ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|:---|:---|
| **æ ‡é¢˜** | Electron Tomography Analysis of Prolamellar Bodies |
| **ä½œè€…** | Xiaohao Cai ç­‰äºº |
| **åº”ç”¨é¢†åŸŸ** | ç»†èƒç”Ÿç‰©å­¦ã€ç”µå­æ˜¾å¾®é•œæˆåƒ |
| **å…³é”®è¯** | Electron Tomography, Prolamellar Body, 3D Reconstruction, Plant Cell |
| **æ ¸å¿ƒä»·å€¼** | ç”µå­æ–­å±‚æˆåƒæŠ€æœ¯åœ¨æ¤ç‰©ç»†èƒå™¨ç ”ç©¶ä¸­çš„åº”ç”¨ |

---

## ğŸ¯ æ ¸å¿ƒé—®é¢˜

### å‰è´¨ä½“(Prolamellar Body)ç®€ä»‹

```
å‰è´¨ä½“ç ”ç©¶èƒŒæ™¯:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

å‰è´¨ä½“ (Prolamellar Body, PLB):
  - æ¤ç‰©ç»†èƒä¸­çš„è†œç»“æ„ç»†èƒå™¨
  - å­˜åœ¨äºé»„åŒ–è‹—(etiolated seedlings)ä¸­
  - å¶ç»¿ä½“å‘è‚²çš„å‰ä½“
  - å…·æœ‰ç‹¬ç‰¹çš„ä¸‰ç»´æ™¶æ ¼ç»“æ„

ç ”ç©¶æ„ä¹‰:
  1. ç†è§£å¶ç»¿ä½“ç”Ÿç‰©å‘ç”Ÿ
  2. å…‰åˆç³»ç»Ÿå‘è‚²æœºåˆ¶
  3. æ¤ç‰©å…‰å½¢æ€å»ºæˆ

æŠ€æœ¯æŒ‘æˆ˜:
  - ç»“æ„å¤æ‚,ä¸‰ç»´é‡å»ºå›°éš¾
  - ä¼ ç»Ÿ2Dç”µé•œæ— æ³•å±•ç¤ºç«‹ä½“ç»“æ„
  - éœ€è¦é«˜åˆ†è¾¨ç‡ä¸‰ç»´æˆåƒ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

### ç”µå­æ–­å±‚æˆåƒæŠ€æœ¯

| æŠ€æœ¯ | åŸç† | åº”ç”¨ |
|:---|:---|:---|
| **TEM** | é€å°„ç”µå­æ˜¾å¾®é•œ | é«˜åˆ†è¾¨ç‡2Dæˆåƒ |
| **ET** | ç”µå­æ–­å±‚æˆåƒ | 3Dé‡å»º |
| ** cryo-ET** | å†·å†»ç”µé•œæ–­å±‚ | è¿‘å¤©ç„¶çŠ¶æ€æˆåƒ |

---

## ğŸ”¬ æ–¹æ³•è®º

### ç”µå­æ–­å±‚æˆåƒæµç¨‹

```
ç”µå­æ–­å±‚æˆåƒå·¥ä½œæµç¨‹:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. æ ·å“åˆ¶å¤‡
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  - åŒ–å­¦å›ºå®šæˆ–å†·å†»å›ºå®š               â”‚
   â”‚  - è¶…è–„åˆ‡ç‰‡ (50-100nm)              â”‚
   â”‚  - é‡é‡‘å±æŸ“è‰² (å¢å¼ºå¯¹æ¯”åº¦)          â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
2. æ•°æ®é‡‡é›†
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  - å€¾æ–œç³»åˆ—æˆåƒ (-70Â° to +70Â°)      â”‚
   â”‚  - æ­¥é•¿: 1-2Â°                       â”‚
   â”‚  - è·å–70-140å¼ æŠ•å½±å›¾åƒ             â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
3. å›¾åƒå¯¹é½
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  - é‡‘é¢—ç²’æ ‡è®°ç‰©è¿½è¸ª                 â”‚
   â”‚  - åŸºäºç‰¹å¾çš„å›¾åƒé…å‡†               â”‚
   â”‚  - æ¶ˆé™¤æœºæ¢°æ¼‚ç§»                     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
4. ä¸‰ç»´é‡å»º
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  - åŠ æƒåæŠ•å½± (WBP)                 â”‚
   â”‚  - SIRTè¿­ä»£é‡å»º                     â”‚
   â”‚  - ç”Ÿæˆ3Dä½“æ•°æ®                     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
5. åˆ†å‰²ä¸åˆ†æ
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  - è†œç»“æ„åˆ†å‰²                       â”‚
   â”‚  - ä¸‰ç»´å¯è§†åŒ–                       â”‚
   â”‚  - å½¢æ€è®¡é‡åˆ†æ                     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

---

### æ ¸å¿ƒç»„ä»¶1: å›¾åƒé…å‡†

```python
import numpy as np
from scipy.ndimage import shift
import cv2

class ElectronTomographyAlignment:
    """
    ç”µå­æ–­å±‚å›¾åƒé…å‡†

    å¯¹é½å€¾æ–œç³»åˆ—å›¾åƒ
    """

    def __init__(self):
        self.reference_idx = 0  # å‚è€ƒå›¾åƒ (0Â°å€¾æ–œ)

    def align_tilt_series(self, tilt_series):
        """
        é…å‡†å€¾æ–œç³»åˆ—å›¾åƒ

        Args:
            tilt_series: å€¾æ–œå›¾åƒåˆ—è¡¨ [(angle, image), ...]

        Returns:
            aligned_series: é…å‡†åçš„å›¾åƒåˆ—è¡¨
            shifts: æ¯å¹…å›¾åƒçš„ä½ç§»
        """
        aligned = []
        shifts = []

        # ä»¥0Â°å›¾åƒä¸ºå‚è€ƒ
        reference = tilt_series[self.reference_idx][1]

        for angle, image in tilt_series:
            # è®¡ç®—ä¸å‚è€ƒå›¾åƒçš„äº’ç›¸å…³
            shift_y, shift_x = self.compute_cross_correlation_shift(
                reference, image
            )

            # åº”ç”¨ä½ç§»
            aligned_image = shift(image, (shift_y, shift_x))

            aligned.append((angle, aligned_image))
            shifts.append((shift_y, shift_x))

        return aligned, shifts

    def compute_cross_correlation_shift(self, ref, img):
        """
        åŸºäºäº’ç›¸å…³çš„ä½ç§»ä¼°è®¡
        """
        # è®¡ç®—äº’ç›¸å…³
        correlation = cv2.matchTemplate(
            ref.astype(np.float32),
            img.astype(np.float32),
            cv2.TM_CCOEFF_NORMED
        )

        # æ‰¾åˆ°æœ€å¤§ç›¸å…³ä½ç½®
        _, _, _, max_loc = cv2.minMaxLoc(correlation)

        # è®¡ç®—ä½ç§»
        center_y, center_x = ref.shape[0] // 2, ref.shape[1] // 2
        shift_x = max_loc[0] - center_x
        shift_y = max_loc[1] - center_y

        return shift_y, shift_x

    def track_fiducial_markers(self, tilt_series, marker_positions):
        """
        åŸºäºé‡‘é¢—ç²’æ ‡è®°ç‰©çš„è¿½è¸ª

        æ›´ç²¾ç¡®çš„é…å‡†æ–¹æ³•
        """
        trajectories = {i: [] for i in range(len(marker_positions))}

        for angle, image in tilt_series:
            for i, (my, mx) in enumerate(marker_positions):
                # åœ¨å½“å‰å›¾åƒä¸­æœç´¢æ ‡è®°ç‰©
                search_window = image[my-10:my+10, mx-10:mx+10]
                cy, cx = np.unravel_index(
                    np.argmax(search_window),
                    search_window.shape
                )

                trajectories[i].append((angle, my-10+cy, mx-10+cx))

        return trajectories
```

---

### æ ¸å¿ƒç»„ä»¶2: ä¸‰ç»´é‡å»º

```python
import numpy as np
from scipy.ndimage import rotate

class TomographicReconstruction:
    """
    æ–­å±‚é‡å»ºç®—æ³•
    """

    def __init__(self, angles):
        self.angles = angles  # å€¾æ–œè§’åº¦åˆ—è¡¨

    def weighted_back_projection(self, aligned_projections):
        """
        åŠ æƒåæŠ•å½± (WBP) é‡å»º

        ç»å…¸è§£æé‡å»ºæ–¹æ³•
        """
        # åˆå§‹åŒ–3Dä½“ç§¯
        size = aligned_projections[0].shape[0]
        volume = np.zeros((size, size, size))

        for angle, projection in zip(self.angles, aligned_projections):
            # æ»¤æ³¢ (Ram-Lakæ»¤æ³¢å™¨)
            filtered_proj = self.ram_lak_filter(projection)

            # åæŠ•å½±
            self.back_project(volume, filtered_proj, angle)

        return volume

    def sirt_reconstruction(self, aligned_projections, iterations=100):
        """
        SIRT (Simultaneous Iterative Reconstruction Technique)

        è¿­ä»£é‡å»ºæ–¹æ³•,å¯¹å™ªå£°æ›´é²æ£’
        """
        # åˆå§‹åŒ–
        size = aligned_projections[0].shape[0]
        volume = np.ones((size, size, size)) * 0.5

        for iter in range(iterations):
            # å‰å‘æŠ•å½±
            projections = self.forward_project(volume, self.angles)

            # è®¡ç®—è¯¯å·®
            errors = [p - proj for p, proj in zip(aligned_projections, projections)]

            # åæŠ•å½±è¯¯å·®
            correction = self.back_project_errors(errors, self.angles)

            # æ›´æ–°ä½“ç§¯
            volume = volume - 0.1 * correction

            # éè´Ÿçº¦æŸ
            volume = np.maximum(volume, 0)

            if iter % 10 == 0:
                error_norm = np.sum([np.sum(e**2) for e in errors])
                print(f"Iteration {iter}: Error = {error_norm:.4f}")

        return volume

    def ram_lak_filter(self, projection):
        """Ram-Lakæ»¤æ³¢å™¨"""
        # 1Då‚…é‡Œå¶å˜æ¢
        f_projection = np.fft.fft(projection, axis=0)

        # é¢‘ç‡åæ ‡
        n = projection.shape[0]
        freq = np.fft.fftfreq(n)

        # Ram-Lakæ»¤æ³¢å™¨ |f|
        filter_response = np.abs(freq)

        # åº”ç”¨æ»¤æ³¢å™¨
        filtered = f_projection * filter_response[:, np.newaxis]

        # é€†å‚…é‡Œå¶å˜æ¢
        return np.real(np.fft.ifft(filtered, axis=0))

    def back_project(self, volume, projection, angle):
        """å•è§’åº¦åæŠ•å½±"""
        angle_rad = np.deg2rad(angle)

        for y in range(volume.shape[1]):
            for z in range(volume.shape[2]):
                # è®¡ç®—æŠ•å½±åæ ‡
                x_proj = int((y - volume.shape[1]/2) * np.cos(angle_rad) +
                           (z - volume.shape[2]/2) * np.sin(angle_rad) +
                           volume.shape[1]/2)

                if 0 <= x_proj < projection.shape[0]:
                    volume[:, y, z] += projection[x_proj, :]

    def forward_project(self, volume, angles):
        """å‰å‘æŠ•å½±"""
        projections = []

        for angle in angles:
            angle_rad = np.deg2rad(angle)
            projection = np.zeros((volume.shape[1], volume.shape[2]))

            # æ—‹è½¬ä½“ç§¯å¹¶æŠ•å½±
            rotated = rotate(volume, angle, axes=(1, 2), reshape=False)
            projection = np.sum(rotated, axis=0)

            projections.append(projection)

        return projections
```

---

### æ ¸å¿ƒç»„ä»¶3: è†œç»“æ„åˆ†å‰²

```python
class MembraneSegmentation:
    """
    è†œç»“æ„åˆ†å‰²

    ä»3Dä½“æ•°æ®ä¸­åˆ†å‰²å‰è´¨ä½“è†œ
    """

    def __init__(self, threshold=0.5):
        self.threshold = threshold

    def segment_membranes(self, volume):
        """
        åˆ†å‰²è†œç»“æ„

        Args:
            volume: 3Dé‡å»ºä½“æ•°æ®

        Returns:
            membrane_mask: è†œç»“æ„æ©ç 
            surface_mesh: è¡¨é¢ç½‘æ ¼
        """
        # 1. é¢„å¤„ç†
        denoised = self.denoise(volume)

        # 2. é˜ˆå€¼åˆ†å‰²
        binary = denoised > self.threshold * denoised.max()

        # 3. å½¢æ€å­¦æ“ä½œ
        from scipy import ndimage
        binary = ndimage.binary_opening(binary, iterations=1)
        binary = ndimage.binary_closing(binary, iterations=1)

        # 4. æå–è¡¨é¢
        surface = self.extract_surface(binary)

        return binary, surface

    def denoise(self, volume):
        """éå±€éƒ¨å‡å€¼å»å™ª"""
        from scipy.ndimage import gaussian_filter
        # ç®€åŒ–: ä½¿ç”¨é«˜æ–¯æ»¤æ³¢
        return gaussian_filter(volume, sigma=1.0)

    def extract_surface(self, binary_volume):
        """
        ä½¿ç”¨Marching Cubesæå–è¡¨é¢
        """
        from skimage import measure

        # æå–ç­‰å€¼é¢
        verts, faces, normals, values = measure.marching_cubes(
            binary_volume.astype(float),
            level=0.5
        )

        return {
            'vertices': verts,
            'faces': faces,
            'normals': normals
        }

    def analyze_membrane_structure(self, membrane_mask):
        """
        åˆ†æè†œç»“æ„ç‰¹å¾
        """
        from scipy import ndimage

        # è®¡ç®—è†œåšåº¦
        distance = ndimage.distance_transform_edt(~membrane_mask)
        thickness = 2 * distance[membrane_mask].mean()

        # è®¡ç®—è¡¨é¢ç§¯
        surface_area = self.compute_surface_area(membrane_mask)

        # è®¡ç®—ä½“ç§¯
        volume = np.sum(membrane_mask)

        # è®¡ç®—æ›²ç‡ç‰¹å¾
        curvature = self.compute_curvature(membrane_mask)

        return {
            'thickness': thickness,
            'surface_area': surface_area,
            'volume': volume,
            'curvature_mean': curvature['mean'],
            'curvature_std': curvature['std']
        }

    def compute_surface_area(self, mask):
        """è®¡ç®—è¡¨é¢ç§¯"""
        # ä½¿ç”¨è¡¨é¢ä½“ç´ è®¡æ•°è¿‘ä¼¼
        from scipy import ndimage
        eroded = ndimage.binary_erosion(mask)
        surface = mask & ~eroded
        return np.sum(surface)

    def compute_curvature(self, mask):
        """è®¡ç®—æ›²ç‡ç‰¹å¾"""
        # ç®€åŒ–çš„æ›²ç‡ä¼°è®¡
        from scipy import ndimage
        laplacian = ndimage.laplace(mask.astype(float))

        return {
            'mean': np.mean(np.abs(laplacian)),
            'std': np.std(laplacian)
        }
```

---

## ğŸ“Š å®éªŒç»“æœ

### å‰è´¨ä½“ç»“æ„ç‰¹å¾

| ç‰¹å¾ | æµ‹é‡å€¼ | è¯´æ˜ |
|:---|:---:|:---|
| **è†œåšåº¦** | 4-5 nm | è„‚è´¨åŒåˆ†å­å±‚ |
| **æ™¶æ ¼é—´è·** | 20-30 nm | ç®¡çŠ¶ç»“æ„å‘¨æœŸ |
| **è¡¨é¢ç§¯/ä½“ç§¯æ¯”** | é«˜ | é«˜åº¦æŠ˜å ç»“æ„ |
| **è¿é€šæ€§** | >95% | è¿ç»­è†œç½‘ç»œ |

### ä¸‰ç»´å¯è§†åŒ–

```
å‰è´¨ä½“ä¸‰ç»´ç»“æ„:

    â•±â•²    â•±â•²
   â•±  â•²  â•±  â•²     ç®¡çŠ¶ç½‘ç»œç»“æ„
  â•±    â•²â•±    â•²
 â•±            â•²
â•±              â•²

ç‰¹å¾:
  - å…­æ–¹æ™¶æ ¼æ’åˆ—
  - é«˜åº¦åˆ†æ”¯çš„ç®¡çŠ¶ç»“æ„
  - è¿ç»­çš„ä¸‰ç»´ç½‘ç»œ
```

---

## ğŸ’¡ å¯¹äº•ç›–æ£€æµ‹çš„å¯ç¤º

### 3Dé‡å»ºæŠ€æœ¯è¿ç§»

```python
class TomographyInspiredDetection:
    """
    å€Ÿé‰´ç”µå­æ–­å±‚æ€æƒ³çš„æ£€æµ‹æ–¹æ³•

    å¤šè§†è§’èåˆæå‡æ£€æµ‹é²æ£’æ€§
    """

    def __init__(self, num_views=8):
        self.num_views = num_views

    def multi_view_detect(self, image_sequence):
        """
        å¤šè§†è§’æ£€æµ‹èåˆ

        Args:
            image_sequence: åŒä¸€åœºæ™¯çš„å¤šè§†è§’å›¾åƒ

        Returns:
            fused_detection: èåˆåçš„æ£€æµ‹ç»“æœ
        """
        detections = []

        for image in image_sequence:
            # å•è§†è§’æ£€æµ‹
            det = self.single_view_detect(image)
            detections.append(det)

        # èåˆæ£€æµ‹ç»“æœ (ç±»ä¼¼æ–­å±‚é‡å»ºçš„åæŠ•å½±)
        fused = self.fuse_detections(detections)

        return fused

    def fuse_detections(self, detections):
        """
        èåˆå¤šè§†è§’æ£€æµ‹ç»“æœ
        """
        # ç´¯ç§¯ç½®ä¿¡åº¦å›¾
        confidence_map = np.zeros((H, W))

        for det in detections:
            # æŠ•å½±åˆ°ç»Ÿä¸€åæ ‡ç³»
            projected = self.project_detection(det)

            # ç´¯åŠ ç½®ä¿¡åº¦
            confidence_map += projected['confidence']

        # é˜ˆå€¼åˆ†å‰²
        final_detections = self.extract_peaks(confidence_map)

        return final_detections
```

---

## ğŸ“– å…³é”®æ¦‚å¿µä¸æœ¯è¯­

| æœ¯è¯­ | è‹±æ–‡ | è§£é‡Š |
|:---|:---|:---|
| **å‰è´¨ä½“** | Prolamellar Body | æ¤ç‰©ç»†èƒä¸­çš„è†œç»“æ„ç»†èƒå™¨ |
| **ç”µå­æ–­å±‚æˆåƒ** | Electron Tomography | åŸºäºç”µå­æ˜¾å¾®é•œçš„3Dæˆåƒ |
| **å€¾æ–œç³»åˆ—** | Tilt Series | ä¸åŒè§’åº¦é‡‡é›†çš„å›¾åƒåºåˆ— |
| **SIRT** | Simultaneous Iterative Reconstruction Technique | è¿­ä»£é‡å»ºç®—æ³• |
| **Marching Cubes** | Marching Cubes | ç­‰å€¼é¢æå–ç®—æ³• |

---

## âœ… å¤ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£ç”µå­æ–­å±‚æˆåƒåŸç†
- [ ] æŒæ¡å›¾åƒé…å‡†æ–¹æ³•
- [ ] äº†è§£3Dé‡å»ºç®—æ³•
- [ ] ç†è§£è†œç»“æ„åˆ†å‰²æŠ€æœ¯

---

**ç¬”è®°åˆ›å»ºæ—¶é—´**: 2026å¹´2æœˆ10æ—¥
**çŠ¶æ€**: å·²å®Œæˆç²¾è¯» âœ…
