# [4-13] è´å£³è®¡ç®—æœºè§†è§‰è¯†åˆ« - ç²¾è¯»ç¬”è®°

> **è®ºæ–‡æ ‡é¢˜**: Computer Vision-Based Limpets Identification
> **é˜…è¯»æ—¥æœŸ**: 2026å¹´2æœˆ10æ—¥
> **éš¾åº¦è¯„çº§**: â­â­â­ (ä¸­ç­‰)
> **é‡è¦æ€§**: â­â­â­ (ç”Ÿæ€ç›‘æµ‹åº”ç”¨)

---

## ğŸ“‹ è®ºæ–‡åŸºæœ¬ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|:---|:---|
| **æ ‡é¢˜** | Computer Vision-Based Limpets Identification |
| **ä½œè€…** | Xiaohao Cai ç­‰äºº |
| **å‘è¡¨æœŸåˆŠ** | Ecological Informatics |
| **å‘è¡¨å¹´ä»½** | 2019 |
| **æ–‡ç« ç±»å‹** | å…¨æ–‡è®ºæ–‡ |
| **å…³é”®è¯** | Computer Vision, Species Identification, Limpets, Morphological Analysis |
| **å½±å“å› å­** | Ecological Informatics (2019) ~3.5 |

---

## ğŸ¯ ç ”ç©¶é—®é¢˜

### è´å£³è¯†åˆ«æŒ‘æˆ˜

**æ ¸å¿ƒé—®é¢˜**: å¦‚ä½•åˆ©ç”¨è®¡ç®—æœºè§†è§‰è‡ªåŠ¨è¯†åˆ«è´å£³ç‰©ç§

**åº”ç”¨åœºæ™¯**:
```
ç”Ÿæ€ç›‘æµ‹:
â”œâ”€â”€ ç‰©ç§å¤šæ ·æ€§è¯„ä¼°
â”œâ”€â”€ ç¯å¢ƒç›‘æµ‹
â”œâ”€â”€ ç”Ÿç‰©å¤šæ ·æ€§ä¿æŠ¤
â””â”€â”€ é•¿æœŸç”Ÿæ€ç ”ç©¶
```

---

## ğŸ”¬ æ–¹æ³•è®ºè¯¦è§£

### æ ¸å¿ƒç»„ä»¶: è´å£³ç‰¹å¾æå–ä¸åˆ†ç±»

```python
import numpy as np
import cv2
from sklearn.ensemble import RandomForestClassifier

class LimpetsIdentifier:
    """
    è´å£³è®¡ç®—æœºè§†è§‰è¯†åˆ«å™¨
    """
    def __init__(self):
        self.classifier = RandomForestClassifier(n_estimators=100)
        self.is_trained = False

    def extract_features(self, image):
        """
        æå–è´å£³å½¢æ€ç‰¹å¾

        Args:
            image: è´å£³å›¾åƒ

        Returns:
            features: ç‰¹å¾å‘é‡
        """
        features = {}

        # é¢„å¤„ç†
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        _, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

        # è½®å»“æ£€æµ‹
        contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        if len(contours) == 0:
            return None

        # æœ€å¤§è½®å»“
        contour = max(contours, key=cv2.contourArea)

        # 1. é¢ç§¯å’Œå‘¨é•¿
        features['area'] = cv2.contourArea(contour)
        features['perimeter'] = cv2.arcLength(contour, True)

        # 2. å½¢çŠ¶æè¿°ç¬¦
        if features['perimeter'] > 0:
            features['compactness'] = 4 * np.pi * features['area'] / (features['perimeter'] ** 2)

        # 3. æ¤­åœ†æ‹Ÿåˆ
        if len(contour) >= 5:
            ellipse = cv2.fitEllipse(contour)
            features['major_axis'] = max(ellipse[1])
            features['minor_axis'] = min(ellipse[1])
            features['eccentricity'] = np.sqrt(1 - (features['minor_axis'] / features['major_axis']) ** 2)
            features['orientation'] = ellipse[2]

        # 4. çº¹ç†ç‰¹å¾ (HuçŸ©)
        moments = cv2.moments(contour)
        hu_moments = cv2.HuMoments(moments).flatten()
        for i, hu in enumerate(hu_moments):
            features[f'hu_{i}'] = -np.sign(hu) * np.log10(abs(hu) + 1e-10)

        # 5. é¢œè‰²ç‰¹å¾
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        features['hue_mean'] = np.mean(hsv[:, :, 0])
        features['saturation_mean'] = np.mean(hsv[:, :, 1])
        features['value_mean'] = np.mean(hsv[:, :, 2])

        return features

    def train(self, images, labels):
        """è®­ç»ƒåˆ†ç±»å™¨"""
        features_list = []
        valid_labels = []

        for img, label in zip(images, labels):
            feats = self.extract_features(img)
            if feats is not None:
                features_list.append(list(feats.values()))
                valid_labels.append(label)

        X = np.array(features_list)
        y = np.array(valid_labels)

        self.classifier.fit(X, y)
        self.is_trained = True

    def predict(self, image):
        """è¯†åˆ«è´å£³"""
        if not self.is_trained:
            raise ValueError("Classifier not trained")

        features = self.extract_features(image)
        if features is None:
            return None

        X = np.array([list(features.values())])
        prediction = self.classifier.predict(X)[0]
        probabilities = self.classifier.predict_proba(X)[0]

        return {
            'species': prediction,
            'confidence': np.max(probabilities),
            'all_probabilities': probabilities
        }
```

---

## ğŸ’¡ å¯¹è¿å»ºæ£€æµ‹çš„è¿ç§»

```python
class BuildingFeatureExtractor:
    """å»ºç­‘ç‰©ç‰¹å¾æå– - åŸºäº[4-13]å½¢æ€å­¦åˆ†æ"""
    def __init__(self):
        pass

    def extract_building_features(self, image):
        """æå–å»ºç­‘ç‰©å½¢æ€ç‰¹å¾"""
        features = {}

        # é¢„å¤„ç†
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        edges = cv2.Canny(gray, 50, 150)

        # è½®å»“
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        if len(contours) > 0:
            largest = max(contours, key=cv2.contourArea)

            # é¢ç§¯
            features['area'] = cv2.contourArea(largest)

            # å‘¨é•¿
            features['perimeter'] = cv2.arcLength(largest, True)

            # çŸ©å½¢åº¦
            x, y, w, h = cv2.boundingRect(largest)
            features['rectangularity'] = features['area'] / (w * h)

            # é•¿å®½æ¯”
            features['aspect_ratio'] = w / (h + 1e-6)

        return features
```

---

**ç¬”è®°åˆ›å»ºæ—¶é—´**: 2026å¹´2æœˆ10æ—¥
**çŠ¶æ€**: å·²å®Œæˆç²¾è¯» âœ…
