<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xcrai.tensor - XCAI API 文档</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h1>XCAI</h1>
            <p class="version">版本 0.1.0</p>
            
            <div class="search-box">
                <input type="text" id="search-input" placeholder="搜索 API...">
                <div id="search-results"></div>
            </div>
            
            <nav>
                <h3>开始</h3>
                <ul>
                    <li><a href="../index.html">概述</a></li>
                    <li><a href="../examples/basic_usage.html">快速开始</a></li>
                    <li><a href="../examples/advanced_usage.html">高级用法</a></li>
                </ul>
                
                <h3>模块</h3>
                <ul>
                    <li><a href="denoising.html">xcrai.denoising</a></li>
                    <li><a href="segmentation.html">xcrai.segmentation</a></li>
                    <li><a href="tensor.html" class="active">xcrai.tensor</a></li>
                    <li><a href="pointcloud.html">xcrai.pointcloud</a></li>
                    <li><a href="peft.html">xcrai.peft</a></li>
                </ul>
            </nav>
        </aside>
        
        <main class="main-content">
            <header class="page-header">
                <h1>xcrai.tensor</h1>
                <p class="breadcrumb">
                    <a href="../index.html">Home</a> / <a href="tensor.html">tensor</a>
                </p>
            </header>
            
            <section class="section">
                <h2>模块简介</h2>
                <p><code>xcrai.tensor</code> 模块提供了张量分解和张量运算的工具，支持 Tucker 分解、CP 分解 (CANDECOMP/PARAFAC) 等主流张量分解方法。这些方法广泛应用于多维数据压缩、特征提取和数据补全等任务。</p>
                
                <div class="example-box">
                    <pre>
<span class="keyword">from</span> xcai.tensor <span class="keyword">import</span> TuckerDecomposer, CPDecomposer

<span class="comment"># Tucker 分解</span>
tucker = <span class="function">TuckerDecomposer</span>(rank=[<span class="string">10</span>, <span class="string">10</span>, <span class="string">5</span>])
core, factors = tucker.<span class="function">decompose</span>(tensor)

<span class="comment"># 重构</span>
reconstructed = tucker.<span class="function">reconstruct</span>(core, factors)
                    </pre>
                </div>
            </section>
            
            <section class="section" id="tuckerdecomposer">
                <h2>TuckerDecomposer</h2>
                
                <div class="class-def">
                    <code>
class <strong>TuckerDecomposer</strong>(rank, init='svd', n_iter_max=100, tol=1e-6, random_state=None)
                    </code>
                </div>
                
                <p>Tucker 张量分解器。Tucker 分解将张量分解为一个核心张量和每个维度上的因子矩阵。</p>
                
                <div class="note">
                    <h5>数学表示</h5>
                    <p>给定张量 X ∈ ℝᴵˣʲˣᴷ，Tucker 分解表示为：</p>
                    <p style="text-align:center; margin: 15px 0;">
                        <code>X ≈ G ×₁ A ×₂ B ×₃ C</code>
                    </p>
                    <p>其中 G 是核心张量，A, B, C 是因子矩阵。</p>
                </div>
                
                <h3>参数</h3>
                <table class="params-table">
                    <thead>
                        <tr>
                            <th>参数名</th>
                            <th>类型</th>
                            <th>默认值</th>
                            <th>描述</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>rank</code></td>
                            <td>list or tuple</td>
                            <td>必填</td>
                            <td>各维度的秩，如 [R1, R2, R3]</td>
                        </tr>
                        <tr>
                            <td><code>init</code></td>
                            <td>str</td>
                            <td>'svd'</td>
                            <td>初始化方法: 'svd' (SVD 初始化), 'random' (随机初始化)</td>
                        </tr>
                        <tr>
                            <td><code>n_iter_max</code></td>
                            <td>int</td>
                            <td>100</td>
                            <td>最大迭代次数</td>
                        </tr>
                        <tr>
                            <td><code>tol</code></td>
                            <td>float</td>
                            <td>1e-6</td>
                            <td>收敛阈值</td>
                        </tr>
                        <tr>
                            <td><code>random_state</code></td>
                            <td>int</td>
                            <td>None</td>
                            <td>随机种子</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>属性</h3>
                <table class="params-table">
                    <thead>
                        <tr>
                            <th>属性名</th>
                            <th>类型</th>
                            <th>描述</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>core_</code></td>
                            <td>ndarray</td>
                            <td>分解后的核心张量</td>
                        </tr>
                        <tr>
                            <td><code>factors_</code></td>
                            <td>list</td>
                            <td>因子矩阵列表</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>示例</h3>
                <div class="example-box">
                    <pre>
<span class="keyword">from</span> xcai.tensor <span class="keyword">import</span> TuckerDecomposer
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># 创建随机张量</span>
tensor = np.random.<span class="function">rand</span>(<span class="string">100</span>, <span class="string">100</span>, <span class="string">50</span>)

<span class="comment"># 创建分解器</span>
decomposer = <span class="function">TuckerDecomposer</span>(
    rank=[<span class="string">20</span>, <span class="string">20</span>, <span class="string">10</span>],
    init=<span class="string">'svd'</span>,
    n_iter_max=<span class="string">100</span>
)

<span class="comment"># 执行分解</span>
core, factors = decomposer.<span class="function">decompose</span>(tensor)

<span class="comment"># 重构张量</span>
reconstructed = decomposer.<span class="function">reconstruct</span>(core, factors)

<span class="comment"># 计算相对误差</span>
error = np.<span class="function">linalg.norm</span>(tensor - reconstructed) / np.<span class="function">linalg.norm</span>(tensor)
<span class="function">print</span>(<span class="string">f'相对误差: {error:.4f}'</span>)
                    </pre>
                </div>
                
                <div class="method" id="decompose">
                    <div class="method-header">
                        <span class="method-name">decompose(tensor)</span>
                    </div>
                    
                    <p>对输入张量执行 Tucker 分解。</p>
                    
                    <div class="method-signature">
decompose(tensor)
                    </div>
                    
                    <h4>参数</h4>
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>参数名</th>
                                <th>类型</th>
                                <th>描述</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>tensor</code></td>
                                <td>ndarray</td>
                                <td>输入张量，支持任意维度的张量</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <div class="returns">
                        <h5>返回值</h5>
                        <table class="params-table">
                            <thead>
                                <tr>
                                    <th>名称</th>
                                    <th>类型</th>
                                    <th>描述</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>core</code></td>
                                    <td>ndarray</td>
                                    <td>核心张量</td>
                                </tr>
                                <tr>
                                    <td><code>factors</code></td>
                                    <td>list</td>
                                    <td>因子矩阵列表，每个元素对应一个维度</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div class="method" id="reconstruct">
                    <div class="method-header">
                        <span class="method-name">reconstruct(core, factors)</span>
                    </div>
                    
                    <p>从核心张量和因子矩阵重构原始张量。</p>
                    
                    <div class="method-signature">
reconstruct(core, factors)
                    </div>
                    
                    <h4>参数</h4>
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>参数名</th>
                                <th>类型</th>
                                <th>描述</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>core</code></td>
                                <td>ndarray</td>
                                <td>核心张量</td>
                            </tr>
                            <tr>
                                <td><code>factors</code></td>
                                <td>list</td>
                                <td>因子矩阵列表</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <div class="returns">
                        <h5>返回值</h5>
                        <p><code>reconstructed</code> - 重构的张量</p>
                    </div>
                </div>
                
                <div class="method">
                    <div class="method-header">
                        <span class="method-name">fit(tensor)</span>
                    </div>
                    
                    <p>拟合分解模型，将结果存储在 <code>core_</code> 和 <code>factors_</code> 属性中。</p>
                    
                    <div class="returns">
                        <h5>返回值</h5>
                        <p><code>self</code> - 返回实例本身</p>
                    </div>
                </div>
            </section>
            
            <section class="section" id="cpdecomposer">
                <h2>CPDecomposer</h2>
                
                <div class="class-def">
                    <code>
class <strong>CPDecomposer</strong>(rank, init='svd', n_iter_max=100, tol=1e-6, random_state=None)
                    </code>
                </div>
                
                <p>CP (CANDECOMP/PARAFAC) 张量分解器。CP 分解将张量分解为秩一张量的和。</p>
                
                <div class="note">
                    <h5>数学表示</h5>
                    <p>给定张量 X ∈ ℝᴵˣʲˣᴷ，CP 分解表示为：</p>
                    <p style="text-align:center; margin: 15px 0;">
                        <code>X ≈ Σᵣ aᵣ ∘ bᵣ ∘ cᵣ</code>
                    </p>
                    <p>其中 ∘ 表示外积，aᵣ, bᵣ, cᵣ 是因子向量。</p>
                </div>
                
                <h3>参数</h3>
                <table class="params-table">
                    <thead>
                        <tr>
                            <th>参数名</th>
                            <th>类型</th>
                            <th>默认值</th>
                            <th>描述</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>rank</code></td>
                            <td>int</td>
                            <td>必填</td>
                            <td>CP 分解的秩（单个整数）</td>
                        </tr>
                        <tr>
                            <td><code>init</code></td>
                            <td>str</td>
                            <td>'svd'</td>
                            <td>初始化方法</td>
                        </tr>
                        <tr>
                            <td><code>n_iter_max</code></td>
                            <td>int</td>
                            <td>100</td>
                            <td>最大迭代次数</td>
                        </tr>
                        <tr>
                            <td><code>tol</code></td>
                            <td>float</td>
                            <td>1e-6</td>
                            <td>收敛阈值</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>示例</h3>
                <div class="example-box">
                    <pre>
<span class="keyword">from</span> xcai.tensor <span class="keyword">import</span> CPDecomposer

decomposer = <span class="function">CPDecomposer</span>(rank=<span class="string">5</span>)
factors = decomposer.<span class="function">decompose</span>(tensor)
                    </pre>
                </div>
            </section>
            
            <section class="section" id="tensorcompletion">
                <h2>TensorCompletion</h2>
                
                <div class="class-def">
                    <code>
class <strong>TensorCompletion</strong>(rank, method='tucker', max_iter=100, tol=1e-4)
                    </code>
                </div>
                
                <p>张量补全器。基于低秩张量分解补全缺失的张量元素。</p>
                
                <h3>参数</h3>
                <table class="params-table">
                    <thead>
                        <tr>
                            <th>参数名</th>
                            <th>类型</th>
                            <th>默认值</th>
                            <th>描述</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>rank</code></td>
                            <td>int or list</td>
                            <td>必填</td>
                            <td>张量的秩</td>
                        </tr>
                        <tr>
                            <td><code>method</code></td>
                            <td>str</td>
                            <td>'tucker'</td>
                            <td>分解方法: 'tucker' 或 'cp'</td>
                        </tr>
                        <tr>
                            <td><code>max_iter</code></td>
                            <td>int</td>
                            <td>100</td>
                            <td>最大迭代次数</td>
                        </tr>
                        <tr>
                            <td><code>tol</code></td>
                            <td>float</td>
                            <td>1e-4</td>
                            <td>收敛阈值</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>示例</h3>
                <div class="example-box">
                    <pre>
<span class="keyword">from</span> xcai.tensor <span class="keyword">import</span> TensorCompletion

<span class="comment"># 创建带缺失值的张量</span>
tensor_with_missing = tensor.<span class="function">copy</span>()
mask = np.random.<span class="function">rand</span>(*tensor.shape) > <span class="string">0.5</span>  <span class="comment"># 50% 缺失</span>
tensor_with_missing[~mask] = np.nan

<span class="comment"># 补全</span>
completer = <span class="function">TensorCompletion</span>(rank=[<span class="string">10</span>, <span class="string">10</span>, <span class="string">5</span>])
completed = completer.<span class="function">complete</span>(tensor_with_missing)
                    </pre>
                </div>
            </section>
            
            <div class="seealso">
                <h5>参见</h5>
                <ul>
                    <li><a href="segmentation.html">xcrai.segmentation</a> - 图像分割模块</li>
                    <li><a href="pointcloud.html">xcrai.pointcloud</a> - 点云处理模块</li>
                </ul>
            </div>
            
            <footer class="footer">
                <p>© 2024 XCAI Team. 基于 Sphinx 风格构建。</p>
            </footer>
        </main>
    </div>
    
    <script src="../js/search.js"></script>
</body>
</html>
